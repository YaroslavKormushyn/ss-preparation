# Active listening

### What to Avoid

- avoid direct attempt at changing the way our listener thinks
 - advice, encouragement, passing judgement (either criticizing or favorable) most of the time is not taken into account - it doesn't work, e.g. "the road to success in business is a long, difficult one, and you must be patient." won't make someone patient or "I’m sure everything will work out O.K." will not make a person, deeply distressed with a problem, believe it's OK

### What to Do

 - understand from the speaker's point of view what he's saying
 - convey to the speaker that we see things from his point of view
 - **listen for total meaning.** A message has two parts: its contents and the feelings behind it. (difference between "I’ve finished that lathe setup." and "Well, I’m finally finished with that damned lathe setup")
 - **respond to feelings.** Sometimes the contents are less important than the underlying feelings. Maybe the contents don't matter at all and are just a tool to get the feeling across. ("I’d like to melt this lathe down and make paper clips out of it" doesn't make sense, but conveys a feeling)
 - **note all cues**. Learn to take into account non-verbal communication like voice inflections, pauses, facial expressions, body posture.

### What We Communicate by Listening
“I’m interested in you as a person, and I think that what you feel is important. I respect your thoughts, and even if I don’t agree with them, I know that they are valid for you. I feel sure that you have a contribution to make. I’m not trying to change you or evaluate you. I just want to understand you. I think you’re worth listening to, and I want you to know that I’m the kind of a person you can talk to.”
This message is better to get across by **demonstration** (listening) and **not** telling.
Listening is contagious: by listening carefully, you encourage careful listening in others. **Listen**, not "*wait out*" the person speaking.

Understanding others is difficult. You can do this by reflecting in your own words what the speaker seems to mean by his words and actions. His response to this will tell you whether or not he feels understood. A good rule of thumb is to assume that you never really understand until you can communicate this understanding to the others satisfaction.
Here is an experiment to test your skill in listening. The next time you become involved in a lively or controversial discussion with another person, stop for a moment and suggest that you adopt this ground rule for continued discussion:Before either participant in the discussion can make a point or express an opinion of his own, he must first restate aloud the previous point or position of the other person. This restatement must be in his own words (merely parroting the words of another does not prove that one has understood but only that he has heard the words). The restatement must be accurate enough to satisfy the speaker before the listener can be allowed to speak for himself.

### Problems in Active Listening

 - sincere interest in the speaker. if we are only making a pretense of interest in the speaker. he will quickly pick this up, either consciously or unconsciously. And once he does, he will no longer express himself freely.
 - we risk seeing the world as the speaker, thus giving up (perhaps momentarily) our own view on the world. This is a risk and takes courage and a requires a fair amount of inner security.

### Steps to Better Active Listening Skills
**1. Restating**
To show you are listening, repeat every so often what you think the person said — not by parroting, but by paraphrasing what you heard in your own words. For example, “Let’s see if I’m clear about this. . .”
**2. Summarizing**
Bring together the facts and pieces of the problem to check understanding — for example, “So it sounds to me as if . . .” Or, “Is that it?”
**3. Minimal encouragers**

Use brief, positive prompts to keep the conversation going and show you are listening — for example, “umm-hmmm,” “Oh?” “I understand,” “Then?” “And?”

**4. Reflecting**

Instead of just repeating, reflect the speaker’s words in terms of feelings — for example, “This seems really important to you. . .”

**5. Giving feedback**

Let the person know what your initial thoughts are on the situation. Share pertinent information, observations, insights, and experiences. Then listen carefully to confirm.

**6. Emotion labeling**

Putting feelings into words will often help a person to see things more objectively. To help the person begin, use “door openers” — for example, “I’m sensing that you’re feeling frustrated. . . worried. . . anxious. . .”

**7. Probing**

Ask questions to draw the person out and get deeper and more meaningful information — for example, “What do you think would happen if you. . .?”

**8. Validation**

Acknowledge the individual’s problems, issues, and feelings. Listen openly and with empathy, and respond in an interested way — for example, “I appreciate your willingness to talk about such a difficult issue. . .”

**9. Effective pause**

Deliberately pause at key points for emphasis. This will tell the person you are saying something that is very important to them.

**10. Silence**

Allow for comfortable silences to slow down the exchange. Give a person time to think as well as  
talk. Silence can also be very helpful in diffusing an unproductive interaction.

**11. “I” messages**

By using “I” in your statements, you focus on the problem not the person. An I-message lets the person know what you feel and why — for example, “I know you have a lot to say, but I need to. . .”

**12. Redirecting**

If someone is showing signs of being overly aggressive, agitated, or angry, this is the time to shift the discussion to another topic.

**13. Consequences**

Part of the feedback may involve talking about the possible consequences of inaction. Take your cues from what the person is saying — for example, “What happened the last time you stopped taking the medicine your doctor prescribed?”

### 7 Communication Blockers

These  [roadblocks](https://psychcentral.com/lib/10-ways-to-find-new-motivation-and-rise-above-roadblocks/)  to communication can stop communication dead in its tracks:

1. “Why” questions. They tend to make people defensive.  
2. Quick reassurance, saying things like, “Don’t worry about that.”  
3. Advising — “I think the best thing for you is to move to assisted living.”  
4. Digging for information and forcing someone to talk about something they would rather not talk about.  
5. Patronizing — “You poor thing, I know just how you feel.”  
6. Preaching — “You should. . .” Or, “You shouldn’t. . .”  
7. Interrupting — Shows you aren’t interested in what someone is saying.

### 5 Simple Conversation Courtesies

1. “Excuse me…”  
2. “Pardon me….”  
3. “One moment please…”  
4. “Let’s talk about solutions.”  
5. “May I suggest something?”

### The Art of Questioning

The four main types of questions are:

**1. Leading Questions**

For example, “Would you like to talk about it?” “What happened then?” Could you tell me more?”

**2. Open-ended Questions**

Use open-ended questions to expand the discussion — for example, lead with: “How? What? Where? Who? Which?”

**3. Closed-ended Questions**

Use closed ended questions to prompt for specifics — for example, lead with: “Is? Are? Do? Did? Can? Could? Would?”

**4. Reflective Questions**

Can help people understand more about what they said — for example, someone tells you, “I’m worried I won’t remember. . . ” Reflective Q: “It sounds like you would like some help remembering?”

**Установки эффективного слушания**  
  
1. Чтобы лучше понять собеседника, его мысли и чувства, необходимо заранее настроиться на то, что разговор с ним будет полезен и приятен, то есть нужна установка одобрения. Она проявляется в положительном отношении к собеседнику, даже если он вам несимпатичен. Доброжелательное отношение со стороны слушающего приводит любого человека в спокойное состояние, при котором ему легче выражать свои мысли, быть более откровенным.  
2. Нужно уметь также сосредоточиться на теме разговора, забыть о своих проблемах, следить за ходом мысли собеседника. Это не всегда легко, так как скорость мышления в 3-4 раза опережает скорость речи. Кроме того, есть любители "растекаться мыслию по древу". Когда становится ясно, о чем собеседник хочет сказать, возникает соблазн перебить его или отдаться течению собственных мыслей. Тут-то и можно пропустить нужный момент и прослыть невежей. Чтобы этого не произошло, используйте высвободившееся время, попробуйте определить приоритетный канал восприятия партнера. Попытайтесь понять, искренен ли партнер, что кроется за его информацией, можно ли ей доверять и т.д. Понаблюдайте за жестами, мимикой, выражением лица партнера. Они дополняют, а нередко и проясняют смысл сказанного.  
3. В деловой информации следует выделять главное, самое существенное и отсеивать не относящееся к делу.  
4. Используйте различные типы и приемы слушания в зависимости от цели говорящего и ситуации общения.  
Добавим, что не следует обращать внимание на разговорные особенности собеседника- неправильные ударения в словах, манеру выражать мысли и вести себя во время беседы. А также не следует стремиться лидировать в разговоре и оставить последнее слово за собой. "Забивая" собеседника своей активностью, мы рискуем упустить то ценное, что могли бы от него услышать.

### Active Listening Requirements
There are four essential requirements for active listening: (1) intensity, (2) empathy, (3) acceptance, and (4) a willingness to take responsibility for completeness.

The active listener concentrates intensely on what the speaker is saying and tunes out the thousands of miscellaneous thoughts (about money, sex, vacations, parties, friends, getting the car fixed, and the like) that create distractions. What do active listeners do with their idle brain time? They summarize and integrate what's been said! They put each new bit of information into the context of what's preceded it.

Empathy requires you to put yourself in the speaker's shoes. You try to understand what the speaker wants to communicate rather than what you want to understand. Notice that empathy demands both knowledge of the speaker and flexibility on your part. You need to suspend your own thoughts and feelings and adjust what you see and feel to your speaker's world. In that way you increase the likelihood that you'll interpret the message in the way the speaker intended.

An active listener  demonstrates acceptance.  He or she listens objectively without judging content. This is no easy task. It's natural to be distracted by the content of what a speaker says, especially when we disagree with it. When we hear something we disagree with, we begin formulating our mental arguments to counter what is being said. Of course, in doing this we miss the rest of the message. The challenge for the active listener is to absorb what's being said and to withhold judgment o content until the speaker is finished.

The final ingredient of active listening is  taking responsibility for completeness. That is, the listener does whatever is necessary to get the full intended meaning from the speaker's communication. Two widely used active listening techniques to achieve this end are listening for feelings as well as for content and asking questions to ensure understanding.

### **Developing Effective Active Listening Skills**

From a review of literature on active listening, we can identify eight specific behaviors that effective active listeners demonstrate. As you review these behaviors, as yourself whether these behaviors describe your listening practices. If you're not cu recently using these techniques, there's no better time than right now to begin developing them.

**Make Eye Contact.** How do you feel when somebody doesn't look at you when you're speaking? If you're like most people, you're likely to interpret this as aloofness or disinterest. It's ironic that while "you listen with your ears, people judge whether you are listening by looking at your eyes." Making eye contact with the speaker focuses your attention, reduces the likelihood that you'll become distracted, an encourages the speaker.

**Exhibit Affirmative Nods and Appropriate Facial Expressions.** The effective listener shows interest in what's being said. How? Through nonverbal signals. Affirmative nods and appropriate facial expressions that signal interest in what's being said, when added to eye contact, convey to the speaker that you're really listening.

**Avoid Distracting Actions or Gestures.** The other side of showing interest avoiding actions that suggest that your mind is somewhere else. When listening don't look at your watch, shuffle papers, play with your pencil, or engage in similar distractions. They make the speaker feel that you're bored or uninterested. Further more, they indicate that you aren't fully attentive and might be missing part of the message that the speaker wants to convey.

**Ask Questions.** The critical listener analyzes what he or she hears and asks quests. This behavior provides clarification, ensures understanding, and assures the speaker that you're listening.

**Paraphrase.** Paraphrasing means restating in your own words what the speaker has said. The effective listener uses phrases as "What I hear you saying is ..." or "Do you mean . . . ?" Why rephrase what's already been said? There are two reasons. First, it's an excellent control device to check on whether you're listening carefully. You can't paraphrase accurately if your mind is wandering or if you're thinking about what you're going to say next. Second, it's a control for accuracy. By rephrasing in your own words what the speaker has said and feeding it back to the speaker, you verify the accuracy of your understanding.

**Avoid Interrupting the Speaker.** Let the speaker complete his or her thoughts before you try to respond. Don't try to second-guess where the speaker's thoughts are going. When the speaker is finished, you'll know it.

**Don't Overtalk.** Most of us would rather speak our own ideas than listen to what someone else says. Too many of us listen only because it's the price we have to pay to get people to let us talk. While talking might be more fun and silence might be uncomfortable, you can't talk and listen at the same time. The good listener recognizes this fact and doesn't overtalk.

**Make Smooth Transitions Between the Roles of Speaker and Listener.** As a student sitting in a classroom, you probably find it relatively easy to get into an effective listening frame of mind. Why? Because communication is essentially one-way; the instructor talks and you listen. But the instructor-student dyad is atypical. In most work situations, you're continually shifting back and forth between the roles of speaker and listener. The effective listener makes transitions smoothly from speaker to listener and back to speaker. From a listening perspective, this means concentrating on what a speaker has to say and practicing not thinking about what you're going to say as soon as you get a chance.


# Conflicts
# Resolving
### Step 1: Prepare for Resolution

-   **Acknowledge the conflict**  – The conflict has to be acknowledged before it can be managed and resolved. The tendency is for people to ignore the first signs of conflict, perhaps as it seems trivial, or is difficult to differentiate from the normal, healthy debate that teams can thrive on. If you are concerned about the conflict in your team, discuss it with other members. Once the team recognizes the issue, it can start the process of resolution.
-   **Discuss the impact**  – As a team, discuss the impact the conflict is having on team dynamics and performance.
-   **Agree to a cooperative process**  – Everyone involved must agree to cooperate in to resolve the conflict. This means putting the team first, and may involve setting aside your opinion or ideas for the time being. If someone wants to win more than he or she wants to resolve the conflict, you may find yourself at a stalemate.
-   **Agree to communicate**  – The most important thing throughout the resolution process is for everyone to keep communications open. The people involved need to talk about the issue and discuss their strong feelings.  [Active listening](https://www.mindtools.com/CommSkll/ActiveListening.htm) is essential here, because to move on you need to really understand where the other person is coming from.

### Step 2: Understand the Situation

Once the team is ready to resolve the conflict, the next stage is to understand the situation, and each team member's point of view. Take time to make sure that each person's position is heard and understood. Remember that strong emotions are at work here so you have to get through the emotion and reveal the true nature of the conflict. Do the following:

-   **Clarify positions**  – Whatever the conflict or disagreement, it's important to clarify people's positions. Whether there are obvious factions within the team who support a particular option, approach or idea, or each team member holds their own unique view, each position needs to be clearly identified and articulated by those involved.
    
    This step alone can go a long way to resolve the conflict, as it helps the team see the facts more objectively and with less emotion.
    
    Sally and Tom believe the best way to market the new product is through a TV campaign. Mary and Beth are adamant that internet advertising is the way to go; whilst Josh supports a store-led campaign.
    
-   **List facts, assumptions and beliefs underlying each position**  – What does each group or person believe? What do they value? What information are they using as a basis for these beliefs? What decision-making criteria and processes have they employed?
    
    Sally and Tom believe that TV advertising is best because it has worked very well in the past. They are motivated by the saying, "If it ain't broke, don't fix it."
    
    Mary and Beth are very tuned-in to the latest in technology and believe that to stay ahead in the market, the company has to continue to try new things. They seek challenges and find change exhilarating and motivating. Josh believes a store-lead campaign is the most cost-effective. He's cautious, and feels this is the best way to test the market at launch, before committing the marketing spend.
    
-   **Analyze in smaller groups**  – Break the team into smaller groups, separating people who are in alliance. In these smaller groups, analyze and dissect each position, and the associated facts, assumptions and beliefs.
    
    Which facts and assumptions are true? Which are the more important to the outcome? Is there additional, objective information that needs to be brought into the discussion to clarify points of uncertainty or contention? Is additional analysis or evaluation required?
    
    #### Tip:
    
    Consider using formal evaluation and decision-making processes where appropriate. Techniques such as  [Quantitative Pros and Cons](https://www.mindtools.com/pages/article/newTED_05.htm) ,  [Force Field Analysis](https://www.mindtools.com/pages/article/newTED_06.htm) ,  [Paired Comparison Analysis](https://www.mindtools.com/pages/article/newTED_02.htm) , and  [Cost/Benefit Analysis](https://www.mindtools.com/pages/article/newTED_08.htm) are among those that could help.
    
    If such techniques have not been used already, they may help make a much more objective decision or evaluation. Gain agreement within the team about which techniques to use, and how to go about the further analysis and evaluation.
    
    By considering the facts, assumptions, beliefs and decision making that lead to other people's positions, the group will gain a better understanding of those positions. Not only can this reveal new areas of agreement, it can also reveal new ideas and solutions that make the best of each position and perspective.
    
    Take care to remain open, rather than criticize or judge the perceptions and assumptions of other people. Listen to all solutions and ideas presented by the various sides of the conflict. Everyone needs to feel heard and acknowledged if a workable solution is to be reached.
    

-   **Convene back as a team**  – After the group dialogue, each side is likely to be much closer to reaching agreement. The process of uncovering facts and assumptions allows people to step away from their emotional attachments and see the issue more objectively. When you separate alliances, the fire of conflict can burn out quickly, and it is much easier to see the issue and facts laid bare.

### Step 3: Reach Agreement

Now that all parties understand the others' positions, the team must decide what decision or course of action to take. With the facts and assumptions considered, it's easier to see the best of action and  [reach agreement](https://www.mindtools.com/pages/article/newTED_86.htm) .

In our example, the team agrees that TV advertising is the best approach. It has had undeniably great results in the past and there is no data to show that will change. The message of the advertising will promote the website and direct consumers there. This meets Mary and Beth's concern about using the website for promotions: they assumed that TV advertising would disregard it.

If further analysis and evaluation is required, agree what needs to be done, by when and by whom, and so plan to reach agreement within a particular timescale. If appropriate, define which decision making and evaluation tools are to be employed.

If such additional work is required, the agreement at this stage is to the approach itself: Make sure the team is committed to work with the outcome of the proposed analysis and evaluation.

#### Tip:
If the team is still not able to reach agreement, you may need to use a techniques like  [Win-Win Negotiation](https://www.mindtools.com/CommSkll/NegotiationSkills.htm) , the  [Modified Borda Count](https://www.mindtools.com/pages/article/newTED_98.htm) , or  [Multi-Voting](https://www.mindtools.com/pages/article/newTMM_97.htm) to find a solution that everyone is happy to move the team ahead.

When conflict is resolved take time to celebrate and acknowledge the contributions everyone made toward reaching a solution. This can build team cohesion and confidence in their problem solving skills, and can help avert further conflict.

This three-step process can help solve team conflict efficiently and effectively. The basis of the approach is gaining understanding of the different perspectives and using that understanding to expand your own thoughts and beliefs about the issue.
# Preventing
As well as being able to handle conflict when it arises, teams need to develop ways of preventing conflict from becoming damaging. Team members can learn skills and behavior to help this. Here are some of the key ones to work on:

-   Dealing with conflict immediately – avoid the temptation to ignore it.
-   Being open – if people have issues, they need to be expressed immediately and not allowed to fester.
-   Practicing clear communication – articulate thoughts and ideas clearly.
-   Practicing active listening – paraphrasing, clarifying, questioning.
-   Practicing identifying assumptions – asking yourself "why" on a regular basis.
-   Not letting conflict get personal – stick to facts and issues, not personalities.
-   Focusing on actionable solutions – don't belabor what can't be changed.
-   Encouraging different points of view – insist on honest dialogue and expressing feelings.
-   Not looking for blame – encourage ownership of the problem and solution.
-   Demonstrating respect – if the situation escalates, take a break and wait for emotions to subside.
-   Keeping team issues within the team – talking outside allows conflict to build and fester, without being dealt with directly.


# Developing others
# Tutoring process
## START OFF RIGHT 
### Establish trust 
 - Make eye contact, smile, give a warm and friendly greeting. Ask check-up questions: what’s due, what’s happening in class, what tests are coming up?  
 - Sit side-by-side, with textbook, notes, paper, pencil, eraser, ruler, calculator, etc. in front of the tutee. Convey that while you are working together, you expect the tutee to take responsibility.

### Define the tasks/ Set the agenda 
 - Decide together what is the most urgent or important work to get done today.
 - Decide together on a realistic overall goal for what you can get done in the session.
 - Break the task into parts and estimate time: ~15 minutes for this, ~10 for that, etc. Keep track of time and progress as you go.

## TUTOR TO ENCOURAGE ACTIVE LEARNING AND INDEPENDENCE 
### Let the tutee take the lead 
 - Have tutee show you everything s/he knows about the task: examples in textbook, class notes, related concepts, how to begin, what to do next, what are most difficult parts.
 - If the student has no idea, probe further to see what is known, and begin there.

### Demonstrate/Explain the tasks 
 - Use visual methods, such as drawings, tables and graphs. Use a whiteboard if available.
 - Use audio methods, such as mnemonics, or rhyming when appropriate.
 - Use “hands-on” methods using any materials you have (index cards, coins, paper clips, etc.)
 - Describe, step by step, the underlying concepts behind the steps, modeling your own process, thinking out loud and SLOWLY doing the task. Write neatly and use appropriate notations.
 - Work out another example, slowly and step-by-step. Ask the tutee to explain WHY.
 - Have the tutee do the task alone, observing keenly, giving LOTS of encouragement and coaching along the way, without rushing. Keep track of any areas of difficulty that stem from lack of understanding of prerequisite material.
 - Check for understanding at each point by asking specific questions (why, how, when etc.)
 - Follow up on any points of difficulty from the prerequisite material.
 - Allow time for thinking and digesting material (10 second rule).
 - Have tutee take notes on the process so he or she can review it later.

### Let the tutee practice the tasks 
 - Give LOTS of (genuine) positive feedback.
 - Check regularly for understanding the concepts. Make notes on areas of difficulty.
 - Ask tutee to explain back what was learned. Pretend you don’t understand and have tutee teach it to you.

## PLAN AHEAD AND END ON A POSITIVE NOTE 
### Review session and check for understanding 
 - Have the tutee summarize what he or she learned in the session.
 - Ask for feedback: did you complete everything you planned to do?
### Close the session / Plans for future 
 - Arrange and pre-plan work for the next session. What is coming up?
 - Give a warm good-bye and a word of encouragement.

## Tutoring
There are many benefits to working as a tutor:

• Experiencing a new role in the learning process.  
• Experiencing higher levels of thinking.  
• Gaining a clearer understanding of the basic skills of a subject.  
• Increased motivation to learn through helping others.  
• Increased ability to manage your own learning and study strategies.  
• Increased subject -specific knowledge.  
• Increased related, general knowledge.  
• Improved listening and communication skills.  
• Increased understanding of learning differences.  
• Increased understanding of cultural differences.  
• Improved organizational abilities.

----------

  
There are also many benefits for the students who receive tutoring:

• A different perspective through individualized and small group learning experiences.  
• A greater connection between teacher and learner through the tutor’s role modeling.  
• Improved academic performance and personal growth.  
• Improved attitude toward subject area.  
• Improved questioning and thinking strategies.  
• Enhanced self-paced and self-directed learning.  
• Opportunity for intensive practice.  
• Improved self esteem.  
• Improved study skills.

### Characteristics of Good Tutors
• A positive outlook: The belief that things can be changed through action.  
  
• A desire to help others: The willingness to become involved with people first  
hand and in depth.  
  
• Empathy: The ability to feel what another person is feeling.  
  
• An even disposition: Patience, gentleness, understanding and fairness.  
  
• An open mind: A willingness to accept other people and their point of view.  
  
• Initiative: The ability to recognize a problem and to do something about it.  
  
• Enthusiasm: A passion for your subject, and a wish to share it with others.  
  
• Reliability as a worker: Punctual, dependable, steady.

----------

  
When considering whether or not to become a tutor, remember these things:

• Tutoring is one of the most beneficial things you can do as a LEARNER. It will teach you more about your subject and about thinking than the typical classroom experience.  
  
• It requires a certain humility to be a tutor. It’s not about you – it’s about the tutee. The more you can focus on the other person’s success, the better the tutor you will be.  
  
• The best tutors do less talking than their tutees. This is a manifestation of allowing the tutee to take charge of her/his own learning.  
  
• Tutoring should not be done for financial reward. Most college programs can’t afford to pay tutors what you’re worth. However, the personal rewards are substantial.  
  
• Tutoring will strengthen your social connection to the campus community. Tutors are universally well respected and appreciated. You will earn a more confident relationship with faculty, staff, and students.  
  
• Tutoring is a two-way learning experience. You will be responsible to establish a friendly atmosphere that is based on mutual respect .  
  
• Prepare for the unknown. A tutor never really knows what kind of questions, assignments, or experiences a tutee will bring to the sessions. That’s why it’s imperative to remain relaxed and flexible .  
  
• Even though you might be demanding on yourself as a student, you will learn the power of patience. You’ll learn this special quality through skilled questioning, listening, and waiting.  
  
• Tutors are problem solvers. You get to figure out what resources and techniques are needed to enable the tutee to succeed.  
  
• Being a good tutor is an art that requires experience and application of proven techniques. Mastering this art form will improve the quality of your work and personal relationships for the rest of your life.

# Kolb's learning cycle
| Stage | Des |  |
|--|--|--|
|  |  |  |



# Feedback

# Performance Appraisals & Phrases
## Effective Words to Use in a Workplace Performance Appraisal
-   **Quality and quantity of work:** _accuracy, thoroughness, productivity,_  and  _goal attainment_
-   **Communication and interpersonal skills:**  _teamwork, cooperation, listening, persuasion,_  and  _empathy_
-   **Planning, administration, and organization:** _goal setting, prioritizing,_  and  _profit orientation_
-   **Leadership:** _accessibility, responsiveness, decisiveness, collaboration,_  and  _delegating_
-   **Job knowledge and expertise:** _knowledge base, training, mentoring, modeling,_  and  _researching_
-   **Attitude:**  _dedication, loyalty, reliability, flexibility, initiative, energy,_  and  _volunteering_
-   **Ethics:**  _diversity, sustainability, honesty, integrity, fairness,_  and  _professionalism_
-   **Creative thinking:** _innovation, receptiveness, problem solving,_  and  _originality_
-   **Self-development and growth:** _learning, education, advancement, skill building,_  and  _career planning_
## Preparing to Appraise Job Performance
-   **See yourself as a leader.**  If you approach the appraisal process as your employees’ buddy, you’ll have difficulty being objective — and they’ll have difficulty accepting your feedback.
-   **Set positive expectations.**  If you expect performance appraisals to go smoothly, effectively, and productively, it’s far more likely that they will.
-   **Spend time with your employees.**  The more familiar you are with your  [employees and their performance](https://www.dummies.com/business/human-resources/employee-relations/managing-employees-build-self-awareness-before-conducting-performance-appraisals/), the more accurate and acceptable your feedback will be.
-   **Know the system.**  Look over your company’s performance appraisal system and be sure you know exactly how it works.
-   **Back-time the process.**  Set the dates of the appraisal sessions first, and then work backward to establish the benchmark actions that you need to complete before meeting with the employees.
-   **Gather and review all the relevant data.**  Look through your notes and supplement them with your employees’ job descriptions, last year’s appraisal, the objectives that you established with your employees, each employee’s file, and your employees’ self-evaluations and 360-degree feedback forms (if you use them).
-   **Complete the evaluation forms.**  Start with written comments and phrases, and then select numerical ratings that fit what you’ve written.  Review the recommended raises, if any, and then finalize the evaluations.
-   **Plan the agenda for the meeting.** Be sure to provide extra time at the end to complete the discussions and answer all questions.
## How to Conduct a Performance Appraisal in the Workplace
-   **Open on an upbeat note.**  Start the discussion with friendly greetings — this sets the tone for the rest of the session.
-   **Lay out the framework.**  Let employees know the topics you plan to cover, as well as the order in which you plan to cover them.
-   **Ask for questions.** This will raise employees’ comfort level and eliminate nagging issues that could distract them.
-   **Focus on performance.**  Keep your feedback focused on your  [employees’ performance](https://www.dummies.com/business/human-resources/employee-relations/taking-the-year-into-account-for-an-employee-appraisal/), especially in terms of meeting objectives, achieving results, handling critical incidents, and developing competencies.
-   **Discuss the evaluations.**  Walk through the evaluations with your employees and provide them with specific information regarding the rationale behind your ratings. If you use self-evaluations, discuss the points where you and your employees agree and disagree.
-   **Listen actively.**  Rephrase and summarize what your employees say, to make sure you truly understand them.
-   **Clarify the overall ratings.**  Discuss the overall ratings with your employees and provide specific information regarding the criteria that you used to determine them.
-   **End the sessions positively.**  Summarize the discussion, ask for final questions, set follow-up dates for goal setting, have the employees sign hard copies of the evaluations, and end with positive expectations.
## How to Follow Up after a Job Performance Appraisal Session
-   **Set performance goals with each employee.** These goals focus on the employee’s specific performance on the job, such as his productivity, output, results, competencies, and behaviors.
-   **Set developmental goals with each employee.**  These goals focus on building the employee’s expertise, skills, and abilities. The idea is to make strengths even stronger, as well as to develop the areas in which the employee’s knowledge and skills are deficient.
-   **Create real goals.** Real goals are specific, achievable, prioritized, measurable, supported by action plans, aligned with the company, linked to your goals, and accepted by you and your employees.
-   **Wander around.** Your effectiveness in the performance appraisal process, as well as your effectiveness as a manager, will be greatly enhanced if you spend time working directly with your employees, observing their performance, and maintaining a high degree of contact and communication with them throughout the evaluation period.
-   **Be a coach.** Take the time to regularly recognize your employees when they’re performing particularly well, and to provide them with formal and informal coaching, guidance, feedback, direction, and follow-up not only to further build their strengths, but also to upgrade their performance in areas where it has fallen short.
-   **Remember your role.**  You are your employees’ central role model, and that makes you their most compelling trainer.
# Performance Feedback Examples
## POSITIVE FEEDBACK  
A positive feedback boosts the confidence of employees and improves their productivity. They feel appreciated as their efforts are recognized, inspiring them to contribute better.  
➠ Reflects a high level of discipline and punctuality and always shows up on time at work. Displays an excellent example to other employees through punctuality.  
➠ Has got strong work ethics and sets an example with his perfect attendance. Is very particular about the attendance of his team members as well, which contributes to the productivity levels of the team, and the organization.  
➠ Encourages effective communication and is a great team player.  
➠ Has excellent time management skills and the ability to meet deadlines in time. His speed and efficiency is an inspirational example to others.  
➠ Has a professional attitude with other co-workers which reflects high productivity in his work. The organization appreciates this dignified demeanor.  
➠ Possesses extremely sound technical and professional skills. The utilization of these skills to the optimum level is evident from his performance.  
➠ Has grown in the last few months by giving promising result through a steady performance. The growth path is definitely positive.  
➠ Comprehends complex situations well and encourages others to perform better.  
➠ The way of handling critical situations with ease has earned him a lot of respect from his team members.  
➠ Is dependable and possesses strong leadership and problem-solving skills.  
➠ Is a divergent thinker and has the ability to come up with creative and innovative solutions.  
## NEGATIVE FEEDBACK  
While giving a negative feedback, it is important to communicate assertively. The purpose is to create awareness and motivate the employees to improve, without affecting their confidence and self-esteem.  
➠ Reports late to work frequently and is not a reliable team player. Displays a wrong example to other employees, especially the employees who have joined recently.  
➠ Does not pay attention during meetings and is not a good listener.  
➠ Needs to develop a constructive and congenial relationship with his manager and team members.  
➠ Lacks confidence and does not take the initiative to take up new assignments.  
➠ Is frequently absent from work and often arrives late. This affects the tasks that have been assigned to him, which reduces the productivity levels of the team, and the organization as a whole.  
➠ Takes more breaks than permitted as per the office rules, which affects the working hours leading to lesser productivity. Should manage work and minimize the break timings.  
➠ Setting unrealistic goals and an overly ambitious attitude has not left a positive impact among the team members.  
➠ There is a lot of scope for performance improvement. The organization will provide all the necessary support to help him learn and improve.  
➠ Has great potential to perform, however, the growth path is not very positive at the moment. Needs to put enough efforts and work hard to perform better.  
➠ The performance has gone down in the past few months. Realizing the efficiency displayed in the past, the organization would help in every possible way to see productivity in the future.  
➠ Needs to have an open mind to learn from seniors or co-workers, so as to ensure productivity and efficiency in the long run.  

**Characteristics of constructive feedback**

Constructive feedback is:

1.  Specific rather than general. To be told that one is "dominating" will not be as useful as being told that, "In the meeting that just took place,
    -   you switched topics without asking if there were additional comments,
    -   you cut people off mid-sentence, and
    -   you interrupted others."
2.  Focused on behavior rather than on the person. It is important that we refer to what a person does. Thus we might describe a person as having "talked more than anyone else in this meeting" rather than saying the person is "a loudmouth." The former allows for the possibility of change; the latter implies a fixed personality trait.
3.  Given in order to help, not hurt. Too often people give feedback to make themselves feel better.
4.  Directed toward behavior which the receiver can do something about. It is pointless and frustrating to be reminded of a trait over which one has no control.
5.  Well-timed. Feedback is most useful at the earliest opportunity after the behavior you want to address has been demonstrated (depending on the person's readiness to hear it, privacy, time available for discussion, etc). Feedback presented at an inappropriate time may do more harm than good.
6.  Limited to the amount of information the receiver can use rather than the amount you would like to give. To overload a person reduces the possibility that the feedback will be used. Additionally, if you give more information than can be used you are likely satisfying some individual need rather than attempting to help the other person.
7.  Checked for clarity. Ask the receiver to rephrase the feedback received to verify that it corresponds to what you had in mind. No matter what the intent, feedback is often perceived as threatening thus subject to considerable distortion or misinterpretation.
8.  Followed up on at a later date. Be aware of the effects of your feedback.

----------

**Giving negative feedback: correcting poor performance**

-   Note poor performance immediately upon observing it.
-   Specify what does not meet expectations.
-   Refer to  [performance standards.](https://hr.iu.edu/training/ca/performance_standards.html)
-   Note the effect of observed performance on work group/organization.
-   Model or restate appropriate performance.
-   Describe negative consequences.
-   Obtain agreement on the problem.
-   Mutually seek solutions.
-   Agree on action plan.
-   Encourage improvement.
-   Set date for check (if appropriate).
-   Don't belabor a point.
-   Move forward after the discussion.
-   Avoid giving correction in public.

----------

**Giving positive feedback: praising good performance**

-   Praise immediately on observing good performance.
-   Be specific about what was good about performance; refer to  [performance standards](https://hr.iu.edu/training/ca/performance_standards.html).
-   Note how meeting (or exceeding) standards helps work group/organization meet strategic objectives.
-   Encourage maintaining this level of performance.


# Meeting skills

## To meet or not to meet
A meeting might be necessary in the following circumstances:
-   When it is important to involve the group in solving a problem or making a decision;
-   When knowledge is dispersed among several people or the commitment of several people is needed;
-   When a major issue needs clarification;
-   When concerns need to be shared with the group or when the group has concerns that need to be addressed by the leader;
-   When a problem involves people from different groups or it isn't clear who is responsible for dealing with it;
-   When members of a large, geographically dispersed group need to get to know one another and develop a shared purpose and collaborative spirit (if it's practical to get the whole group together in one location);
-   When a meeting may help to avoid multiple e-mails and rounds of phone tag that take more time than you think the meeting will.
    
Too often, meetings are held that ought to be postponed. The time would be better spent on something else in cases like these:
-   When important data are unavailable or essential handouts have not been completed and distributed;
-   When key participants cannot be present;
-   When there is significant anger or hostility in the group (this should be addressed in one-on-one discussions until all parties are reasonably confident that a productive group discussion can occur).

## Planning the meeting
Goals and agenda-setting. What do you want to accomplish with this meeting? Make sure that the agenda addresses this purpose. The first item should be the minutes of the previous meeting, if there was a previous meeting at which minutes were taken. Other items should be prioritized, with those requiring the most discussion coming first. Put informational items and less controversial items at the end of the agenda. Intersperse them if needed to avoid putting too many difficult items back to back. Only allow the number of items that can be covered in the allotted time. If you know of meeting attendees who are strongly in favor of or against any particular agenda item, talking informally with them about the issue before the meeting may save time during the meeting. If your goal is to move an initiative forward, it can be particularly helpful to talk with dissenters before the meeting to try to enlist their help.

Participants. The decision regarding who should be invited to attend a meeting should be based on the type of meeting and the desired outcome. Those who have a need to know and those who have relevant information to share may need to be present at the meeting. Those affected by the decision may also need to be included. In most cases, limit the number of attendees to 12; with more, the discussion can become unwieldy. Avoid being overly inclusive, which may only waste people's time.

Facilities. When the meeting facilities are proper, they go unnoticed. How many times have you been in a meeting where the room was too hot and everyone fell asleep? How about the meeting where the overhead fan was so loud you couldn't hear the speaker? Heating, cooling, lighting and ventilation should be adequate and checked prior to the meeting. For meetings that will last more than an hour, the chairs should have cushions, if possible. For meetings that require interactive discussion, participants should be seated at a conference style table, facing one another.

### HOW TO BE A GOOD MEETING ATTENDEE

Question the need for the meeting, if appropriate.  Others, including the meeting leader, may thank you for it.

RSVP if necessary.  Letting the meeting planner know whether you will be coming helps him or her to anticipate space needs and may affect whether the meeting occurs at all.

Arrive on time.  If you have to be late, don't expect the meeting leader or the person sitting next to you to fill you in on what you missed.

Come prepared.  Read related material, particularly any distributed by the meeting organizer prior to the meeting. Bring the material with you, along with paper and a pen.

Listen carefully.  This will prevent you from asking questions that have already been covered.

Don't interrupt.  In a more formal meeting, you may need to ask the leader to acknowledge you by raising your hand.

Don't be a distraction.  Silence your cell phone and pager, and avoid side conversations.

Participate.  People will interpret your silence in different ways, many of which don't accurately reflect what's really on your mind.

Don't monopolize the discussion.  Keep your questions brief, and allow others ample opportunity to speak. If appropriate, you may want to encourage others to participate.

## Managing the meeting
1. Start and finish on time
2. Stay focused on the goal: don't turn an informational meeting to a brainstorming session

### How to deal with challenging attendees
The know-it-all. This person believes himself or herself to be an expert in the issues being discussed, offers many strong opinions and delights in crossing up the leader. Turn him or her over to the group by asking others what they think about an item that this person has brought up.

The talker. Like the know-it-all, this person has a lot to say and can monopolize the discussion. Avoid eye contact with him or her. When he or she completes a thought, ask others to offer their point of view, for example, by saying, “We've heard what John has to say. I'd like to hear what others in the group think.”

The side conversationalists. These are the two who have something to say to each other during the meeting. If their conversation is brief, ignore it. If it is prolonged, or if it occurs repeatedly throughout the meeting, you should address the situation. Invite them to share their comments with the group – like your teacher did in third grade. It still works.

The timid one. This person never contributes. Don't mistake his or her silence for agreement. Many times it comes from a lack of self-confidence or fear of embarrassment. Calling on the person may be all that is needed to elicit useful input. Office staff may need extra encouragement to speak up in meetings that involve physicians and nursing staff. If possible, ask the person questions he or she is uniquely suited to answer based on his or her knowledge or expertise. Reserved individuals often put a lot of thought into what they say and can make valuable contributions with some encouragement.

# Process planning


In [software engineering](https://en.wikipedia.org/wiki/Software_engineering "Software engineering"), a **software development process** is the process of dividing [software development](https://en.wikipedia.org/wiki/Software_development "Software development") work into distinct phases to improve [design](https://en.wikipedia.org/wiki/Software_design "Software design"), [product management](https://en.wikipedia.org/wiki/Software_product_management "Software product management"), and [project management](https://en.wikipedia.org/wiki/Software_project_management "Software project management"). It is also known as a **software development life cycle** (**SDLC**). The methodology may include the pre-definition of specific [deliverables](https://en.wikipedia.org/wiki/Deliverable "Deliverable") and artifacts that are created and completed by a project team to develop or maintain an application.

Most modern development processes can be vaguely described as [agile](https://en.wikipedia.org/wiki/Agile_software_development "Agile software development"). Other methodologies include [waterfall](https://en.wikipedia.org/wiki/Waterfall_model "Waterfall model"), [prototyping](https://en.wikipedia.org/wiki/Software_prototyping "Software prototyping"), [iterative and incremental development](https://en.wikipedia.org/wiki/Iterative_and_incremental_development "Iterative and incremental development"), [spiral development](https://en.wikipedia.org/wiki/Spiral_development "Spiral development"), [rapid application development](https://en.wikipedia.org/wiki/Rapid_application_development "Rapid application development"), and [extreme programming](https://en.wikipedia.org/wiki/Extreme_programming "Extreme programming").

### Waterfall development

Main article: [Waterfall model](https://en.wikipedia.org/wiki/Waterfall_model "Waterfall model")


[![](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/Waterfall_model.svg/220px-Waterfall_model.svg.png)
](https://en.wikipedia.org/wiki/File:Waterfall_model.svg)

The activities of the software development process represented in the [waterfall model](https://en.wikipedia.org/wiki/Waterfall_model "Waterfall model"). There are several other models to represent this process.

The waterfall model is a sequential development approach, in which development is seen as flowing steadily downwards (like a waterfall) through several phases, typically:

-   [Requirements analysis](https://en.wikipedia.org/wiki/Requirements_analysis "Requirements analysis") resulting in a [software requirements specification](https://en.wikipedia.org/wiki/Software_requirements_specification "Software requirements specification")
-   [Software design](https://en.wikipedia.org/wiki/Software_design "Software design")
-   [Implementation](https://en.wikipedia.org/wiki/Computer_programming "Computer programming")
-   [Testing](https://en.wikipedia.org/wiki/Software_testing "Software testing")
-   [Integration](https://en.wikipedia.org/wiki/System_integration "System integration"), if there are multiple subsystems
-   [Deployment](https://en.wikipedia.org/wiki/Software_deployment "Software deployment") (or [Installation](https://en.wikipedia.org/wiki/Installation_(computer_programs) "Installation (computer programs)"))
-   [Maintenance](https://en.wikipedia.org/wiki/Software_maintenance "Software maintenance")

The first formal description of the method is often cited as an article published by [Winston W. Royce](https://en.wikipedia.org/wiki/Winston_W._Royce "Winston W. Royce") in 1970 although Royce did not use the term "waterfall" in this article. Royce presented this model as an example of a flawed, non-working model.

The basic principles are:

-   Project is divided into sequential phases, with some overlap and splashback acceptable between phases.
-   Emphasis is on planning, time schedules, target dates, budgets and implementation of an entire system at one time.
-   Tight control is maintained over the life of the project via extensive written documentation, formal reviews, and approval/signoff by the user and information technology management occurring at the end of most phases before beginning the next phase. Written documentation is an explicit deliverable of each phase.

The waterfall model is a traditional engineering approach applied to software engineering. A strict waterfall approach discourages revisiting and revising any prior phase once it is complete. This "inflexibility" in a pure waterfall model has been a source of criticism by supporters of other more "flexible" models. It has been widely blamed for several large-scale government projects running over budget, over time and sometimes failing to deliver on requirements due to the [Big Design Up Front](https://en.wikipedia.org/wiki/Big_Design_Up_Front "Big Design Up Front") approach. Except when contractually required, the waterfall model has been largely superseded by more flexible and versatile methodologies developed specifically for software development. See [Criticism of Waterfall model](https://en.wikipedia.org/wiki/Waterfall_model#Criticism "Waterfall model").

# Agile software development
**Agile software development** comprises various approaches to [software development](https://en.wikipedia.org/wiki/Software_development "Software development") under which requirements and solutions evolve through the collaborative effort of [self-organizing](https://en.wikipedia.org/wiki/Self-organizing_communities "Self-organizing communities") and [cross-functional](https://en.wikipedia.org/wiki/Cross-functional_team "Cross-functional team") teams and their [customer(s)](https://en.wikipedia.org/wiki/Customer "Customer")/[end user(s)](https://en.wikipedia.org/wiki/End_user "End user"). It advocates adaptive planning, evolutionary development, early delivery, and [continual improvement](https://en.wikipedia.org/wiki/Continual_improvement_process "Continual improvement process"), and it encourages rapid and flexible response to change. explanation needed](https://en.wikipedia.org/wiki/Wikipedia:Please_clarify "Wikipedia:Please clarify")_]

The term _agile_ (sometimes written _Agile_) was popularized, in this context, by the _[Manifesto for Agile Software Development](https://en.wikipedia.org/wiki/Agile_software_development#The_Agile_Manifesto)_. The values and principles espoused in this manifesto were derived from and underpin a broad range of [software development frameworks](https://en.wikipedia.org/wiki/Software_development_process "Software development process"), including [Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development) "Scrum (software development)") and [Kanban](https://en.wikipedia.org/wiki/Kanban_(development) "Kanban (development)").

While there is much anecdotal evidence that adopting agile practices and values improves the agility of software professionals, teams and organizations, some empirical studies have disputed that evidence.

### Agile software development values

Based on their combined experience of developing software and helping others do that, the seventeen signatories to the manifesto proclaimed that they value:

-   _**Individuals and Interactions** over processes and tools_
-   _**Working Software** over comprehensive documentation_
-   _**Customer Collaboration** over contract negotiation_
-   _**Responding to Change** over following a plan_

That is to say, the items on the left are valued more than the items on the right.
### Agile software development principles

The _Manifesto for Agile Software Development_ is based on twelve principles:[[22]](https://en.wikipedia.org/wiki/Agile_software_development#cite_note-ManifestoPrinciples-22)

1.  Customer satisfaction by early and continuous delivery of valuable software.
2.  Welcome changing requirements, even in late development.
3.  Deliver working software frequently (weeks rather than months)
4.  Close, daily cooperation between business people and developers
5.  Projects are built around motivated individuals, who should be trusted
6.  Face-to-face conversation is the best form of communication (co-location)
7.  Working software is the primary measure of progress
8.  Sustainable development, able to maintain a constant pace
9.  Continuous attention to technical excellence and good design
10.  Simplicity—the art of maximizing the amount of work not done—is essential
11.  Best architectures, requirements, and designs emerge from self-organizing teams
12.  Regularly, the team reflects on how to become more effective, and adjusts accordingly

### Agile vs. waterfall

One of the differences between agile software development methods and waterfall is the approach to quality and testing. In the [waterfall model](https://en.wikipedia.org/wiki/Waterfall_model "Waterfall model"), there is always a separate _**testing phase**_ after a _**build phase**_; however, in agile software development testing is completed in the same iteration as programming.

Another difference is that traditional "waterfall" software development moves a project through various Software Development Lifecycle (SDLC) phases. One phase is completed in its entirety before moving on to the next phase.

Because testing is done in every iteration—which develops a small piece of the software—users can frequently use those new pieces of software and validate the value. After the users know the real value of the updated piece of software, they can make better decisions about the software's future. Having a value retrospective and software re-planning session in each iteration—[Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development) "Scrum (software development)") typically has iterations of just two weeks—helps the team continuously adapt its plans so as to maximize the value it delivers. This follows a pattern similar to the [PDCA](https://en.wikipedia.org/wiki/PDCA "PDCA") cycle, as the work is _planned_, _done_, _checked_ (in the review and retrospective), and any changes agreed are _acted_ upon.

This iterative approach supports a _product_ rather than a _project_ mindset. This provides greater flexibility throughout the development process; whereas on projects the requirements are defined and locked down from the very beginning, making it difficult to change them later. Iterative product development allows the software to evolve in response to changes in business environment or market requirements.[[38]](https://en.wikipedia.org/wiki/Agile_software_development#cite_note-38)

Because of the short iteration style of agile software development, it also has strong connections with the [lean startup](https://en.wikipedia.org/wiki/Lean_startup "Lean startup") concept.

## Agile software development methods


[![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/SoftwareDevelopmentLifeCycle.jpg/220px-SoftwareDevelopmentLifeCycle.jpg)](https://en.wikipedia.org/wiki/File:SoftwareDevelopmentLifeCycle.jpg)


Software development life-cycle support[[43]](https://en.wikipedia.org/wiki/Agile_software_development#cite_note-Abrahamsson2002-43)

Agile software development methods support a broad range of the [software development life cycle](https://en.wikipedia.org/wiki/Software_development_life_cycle "Software development life cycle").[[43]](https://en.wikipedia.org/wiki/Agile_software_development#cite_note-Abrahamsson2002-43) Some focus on the practices (e.g., XP, pragmatic programming, agile modeling), while some focus on managing the flow of work (e.g., Scrum, Kanban). Some support activities for requirements specification and development (e.g., FDD), while some seek to cover the full development life cycle (e.g., DSDM, [RUP](https://en.wikipedia.org/wiki/Rational_Unified_Process "Rational Unified Process")).

| Framework | Main contributor(s) |
| --- | --- |
| [Adaptive software development](https://en.wikipedia.org/wiki/Adaptive_software_development) (ASD) | [Jim Highsmith](https://en.wikipedia.org/wiki/Jim_Highsmith), Sam Bayer |
| [Agile modeling](https://en.wikipedia.org/wiki/Agile_modeling) | [Scott Ambler](https://en.wikipedia.org/wiki/Scott_Ambler), [Robert Cecil Martin](https://en.wikipedia.org/wiki/Robert_Cecil_Martin) |
| [Agile unified process](https://en.wikipedia.org/wiki/Agile_Unified_Process) (AUP) | [Scott Ambler](https://en.wikipedia.org/wiki/Scott_Ambler) |
| [Disciplined agile delivery](https://en.wikipedia.org/wiki/Disciplined_agile_delivery) | [Scott Ambler](https://en.wikipedia.org/wiki/Scott_Ambler) |
| [Dynamic systems development method](https://en.wikipedia.org/wiki/Dynamic_systems_development_method) (DSDM) |   |
| [Extreme programming](https://en.wikipedia.org/wiki/Extreme_programming) (XP) | [Kent Beck](https://en.wikipedia.org/wiki/Kent_Beck), [Robert Cecil Martin](https://en.wikipedia.org/wiki/Robert_Cecil_Martin) |
| [Feature-driven development](https://en.wikipedia.org/wiki/Feature-driven_development) (FDD) | [Jeff De Luca](https://en.wikipedia.org/wiki/Jeff_De_Luca) |
| [Lean software development](https://en.wikipedia.org/wiki/Lean_software_development) | Mary Poppendieck, Tom Poppendieck |
| [Lean startup](https://en.wikipedia.org/wiki/Lean_startup) | [Eric Ries](https://en.wikipedia.org/wiki/Eric_Ries) |
| [Kanban](https://en.wikipedia.org/wiki/Kanban_(development)) | [Taiichi Ohno](https://en.wikipedia.org/wiki/Taiichi_Ohno) |
| [Rapid application development](https://en.wikipedia.org/wiki/Rapid_application_development) (RAD) | [James Martin](https://en.wikipedia.org/wiki/James_Martin_(author)) |
| [Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)) | [Ken Schwaber](https://en.wikipedia.org/wiki/Ken_Schwaber), [Jeff Sutherland](https://en.wikipedia.org/wiki/Jeff_Sutherland) |
| [Scrumban](https://en.wikipedia.org/wiki/Scrumban) |   |
| [Scaled Agile Framework - SAFe](https://en.wikipedia.org/wiki/Scaled_agile_framework) |   |

## Scrum
Scrum (n): A framework within which people can address complex adaptive problems, while productively and creatively delivering products of the highest possible value.
Scrum is a process framework that has been used to manage complex product development since the early 1990s. Scrum is not a process or a technique for building products; rather, it is a framework within which you can employ various processes and techniques. Scrum makes clear the relative efficacy of your product management and development practices so that you can improve.The Scrum framework consists of Scrum Teams and their associated roles, events, artifacts, and rules. Each component within the framework serves a specific purpose and is essential to Scrum’s success and usage.
### Scrum Theory
Scrum is founded on empirical process control theory, or empiricism.Empiricism asserts that knowledge comes from experience andmaking decisions basedon what is known.Scrumemploys an iterative, incremental approach to optimize predictability and control risk. Three pillars uphold every implementation of empirical process control: transparency, inspection, and adaptation.

#### Transparency

Significant aspects of theprocess must be visible to those responsible for the outcome. Transparency requires those aspects be defined by a common standard so observers share a common understanding of what is being seen.For example:
A common language referring to the process must beshared by all participants; and,
Those performing the work and those accepting the work product must share a common definition of “Done”.

#### Inspection

Scrum users must frequently inspect Scrum artifacts and progress toward a Sprint Goal to detect undesirable variances. Their inspection should not be so frequent that inspection gets in the way of the work. Inspections are most beneficial when diligently performed by skilled inspectors at the point of work.

#### Adaptation

If aninspector determines that one or more aspects of aprocess deviate outsideacceptable limits, and that the resulting product will be unacceptable, the process or the material being processedmust be adjusted. Anadjustment must be made as soonas possible to minimize further deviation.Scrum prescribes four formal events for inspection and adaptation, as described in the ScrumEventssectionof this document:
Sprint Planning
Daily Scrum 
Sprint Review
Sprint Retrospective

### The Scrum Team

The Scrum Team consists of a Product Owner, the Development Team, and a Scrum Master. Scrum Teams are self-organizing and cross-functional. Self-organizing teams choose how best to accomplish their work, rather than being directed by others outside the team. Cross-functional teams have all competencies needed to accomplish the work without depending on others not part of the team. The team model in Scrum is designed to optimize flexibility, creativity, and productivity.Scrum Teams deliver products iteratively and incrementally, maximizing opportunities for feedback. Incremental deliveries of “Done”product ensure a potentially useful version of working product is always available.

#### The Product Owner
The Product Owner is responsible for maximizing the value of the product and the work of the Development Team. How this is done may vary widely across organizations, Scrum Teams, and individuals.
The Product Owner is the sole person responsible for managing the Product Backlog. Product Backlog management includes:
Clearly expressing Product Backlog items;
Ordering the items in the Product Backlog to best achieve goals and missions;
Optimizing the value of the work the Development Team performs;
Ensuring that the Product Backlog is visible, transparent, and clear to all, and shows what the Scrum Team will work on next; and,
Ensuring the Development Team understands items in the Product Backlog to the level
needed.
The Product Owner may do the above work, or have the Development Team do it. However, the Product Owner remains accountable.
The Product Owner is one person, not a committee. The Product Owner may represent the
desires of a committee in the Product Backlog, but those wanting to change a Product Backlog item’s priority must address the Product Owner.
For the Product Owner to succeed, the entire organization must respect his or her decisions. The
Product Owner’s decisions are visible in the content and ordering of the Product Backlog. No
one is allowed to tell the Development Team to work from a different set of requirements, and
the Development Team isn’t allowed to act on what anyone else says.
#### The Development Team
The Development Team consists of professionals who do the work of delivering a potentially
releasable Increment of “Done” product at the end of each Sprint. Only members of the
Development Team create the Increment.
Development Teams are structured and empowered by the organization to organize and
manage their own work. The resulting synergy optimizes the Development Team’s overall
efficiency and effectiveness.
Development Teams have the following characteristics:
They are self-organizing. No one (not even the Scrum Master) tells the Development Team
how to turn Product Backlog into Increments of potentially releasable functionality;
Development Teams are cross-functional, with all of the skills as a team necessary to create
a product Increment;
Scrum recognizes no titles for Development Team members other than Developer,
regardless of the work being performed by the person; there are no exceptions to this rule;
Scrum recognizes no sub-teams in the Development Team, regardless of particular domains
that need to be addressed like testing or business analysis; there are no exceptions to this
rule; and,
Individual Development Team members may have specialized skills and areas of focus, but
accountability belongs to the Development Team as a whole.

Team size 3 to 9 people (not counting Scrum Master and Product Owner, unless they are part of Dev Team).

#### The Scrum Master
The Scrum Master is responsible for ensuring Scrum is understood and enacted. Scrum Masters
do this by ensuring that the Scrum Team adheres to Scrum theory, practices, and rules.
The Scrum Master is a servant-leader for the Scrum Team. The Scrum Master helps those
outside the Scrum Team understand which of their interactions with the Scrum Team are helpful
and which aren’t. The Scrum Master helps everyone change these interactions to maximize the
value created by the Scrum Team.
Scrum Master Service to the Product Owner
The Scrum Master serves the Product Owner in several ways, including:

 - Finding techniques for effective Product Backlog management;
 - Helping the Scrum Team understand the need for clear and concise
   Product Backlog items;
 - Understanding product planning in an empirical environment;
 - Ensuring the Product Owner knows how to arrange the Product Backlog
   to maximize value;
 - Understanding and practicing agility; and,
 - Facilitating Scrum events as requested or needed.

##### Scrum Master Service to the Development Team
The Scrum Master serves the Development Team in several ways, including:
Coaching the Development Team in self-organization and cross-functionality;
Helping the Development Team to create high-value products;
Removing impediments to the Development Team’s progress;
Facilitating Scrum events as requested or needed; and,
Coaching the Development Team in organizational environments in which Scrum is not yet
fully adopted and understood.

##### Scrum Master Service to the Organization
The Scrum Master serves the organization in several ways, including:
Leading and coaching the organization in its Scrum adoption;
Planning Scrum implementations within the organization;
Helping employees and stakeholders understand and enact Scrum and empirical product
development;
Causing change that increases the productivity of the Scrum Team; and,
Working with other Scrum Masters to increase the effectiveness of the application of Scrum
in the organization.

### Scrum Events
Prescribed events are used in Scrum to create regularity and to minimize the need for meetings
not defined in Scrum. All events are time-boxed events, such that every event has a maximum
duration. Once a Sprint begins, its duration is fixed and cannot be shortened or lengthened. The
remaining events may end whenever the purpose of the event is achieved, ensuring an
appropriate amount of time is spent without allowing waste in the process.
Other than the Sprint itself, which is a container for all other events, each event in Scrum is a
formal opportunity to inspect and adapt something. These events are specifically designed to
enable critical transparency and inspection. Failure to include any of these events results in
reduced transparency and is a lost opportunity to inspect and adapt.
#### The Sprint
 - iteration of a scrum project
 - 1 to 4 weeks
 - have index numbers, starting from 0 - sprint 0 is preparing the dev environment for the team, carrying out preliminary planning before the actual sprints (no point associated with this)
 - best to start sprints midweek (Tue, Wed, Thu) so sprint planning and retrospective aren't on Mon and Fri (inconvenient and energy-sapping)
 - 
The heart of Scrum is a Sprint, a time-box of one month or less during which a “Done”, useable,
and potentially releasable product Increment is created. Sprints best have consistent durations
throughout a development effort. A new Sprint starts immediately after the conclusion of the
previous Sprint.
Sprints contain and consist of the Sprint Planning, Daily Scrums, the development work, the
Sprint Review, and the Sprint Retrospective.
During the Sprint:
No changes are made that would endanger the Sprint Goal;
Quality goals do not decrease; and,
Scope may be clarified and re-negotiated between the Product Owner and Development
Team as more is learned.
Each Sprint may be considered a project with no more than a one-month horizon. Like projects,
Sprints are used to accomplish something. Each Sprint has a definition of what is to be built, a
design and flexible plan that will guide building it, the work, and the resultant product.
Sprints are limited to one calendar month. When a Sprint’s horizon is too long the definition of
what is being built may change, complexity may rise, and risk may increase. Sprints enable
predictability by ensuring inspection and adaptation of progress toward a Sprint Goal at least
every calendar month. Sprints also limit risk to one calendar month of cost.
#### Release planning
 - before beginning the sprint
 - customer and product owner decide on a release date, prioritize and size the features to include
##### Feature estimation
 - in t-shirt sizes (xl, l, m, s, xs)
##### Feature priority
 - required (R) - part of MVP
 - preferred (P)
 - desired (D)
#### Release planning
 - expected outcome of sprint planning is to estimate user stories.
##### Planning poker
 - session involves the whole development team—business analysts, developers, and test analysts—including the Scrum master and the product owner.
 - For every user story that is currently on the product backlog, a small scope explanation is given, and then everyone is asked to vote on its size in story points.
 - points are in Fibonacci scale 1 to 20, 40, 100, to limit the options
 - everyone shows cards with votes at the same time to avoid being influenced by others
 - people who have deviated the most from the common point should explain their view - after the discussion there is a revote
 - estimation continues until the sum of points is at the team's velocity
##### Affinity estimation
 - provided as a counterpoint to planning poker, which can take a significant amount of time to generate estimates if there are a lot of stories.
 - the team picks two stories from the top of the product backlog and then decides which is the smaller of the two. The smaller is placed on the left side of a table and the larger on the right. - no discussion around each separate story
 - then we take one top story from the product backlog and place it somewhere on the horizontal axis where the estimated stories are: if it's small - on the left, big - right; it's either between stories or bigger than the biggest / smaller than the smallest
 - take stories until maximum work for sprint is achieved
 - then estimate with fibonacci scale going left to right
#### Daily scrum
 - “stand-up meeting.”
 - less than 15 min
	- What did you do yesterday?
	- What will you do today?
	- What impediments do you face?
 - If you do not have anything to do at this point, notify the Scrum master and request a new work item.
 - The impediment could be directly work related,or it might be a personal matter,
 - tangents should be discussed separately in order not to take everyone's time
#### Sprint demo
It is a showcase of all of the completed stories—those that have met the definition of done during the sprint—in action in a real environment. The entire development team should be present, and you could also invite other stakeholders to the meeting, such as management or sales team representatives. Anyone who might have an interest in the project’s progress should be free to attend.
 - collect completed user stories for the sprint, explain scope for each
 - demonstrate in on real environment
 - Any suggestions for improvements should feed back into the product backlog so that they are correctly prioritized and scheduled
#### Sprint retrospective
What went well?
What went badly?
What do we need to start doing?
What do we need to stop doing?
What do we need to continue doing?
Did we experience any surprises during the sprint?

The outcomes of this meeting should not be forgotten; they should be acted on.
Answers should be reviewed in the next retrospective to ensure progress.
At least one action item from the retrospective should be prioritized for the next sprint.


### Artifacts
##### The Scrum board
central to a scrum project. is a whiteboard with status columns.
primary items are Cards. 
##### Cards
Cards have different levels:
- product - contains releases
- release - contains features (MVP - minimum viable release - first release with basic set of features enough to fulfill fundamental requirements)
- feature - contains stories (MMF - minimum marketable feature - if they have some value for the customer) - required, preferred, desired (3 priority categories)
- story - has story points; story points are subtracted from sprint only when story has been completed, not partially (As a [user role], I want to [behavior], so that [user value].) - has a definition of done
	-	task
	-	defect
		-	created when acceptance criteria are not met on a previously complete user story 
		-	A,B,C categories: apocalyptic defects, behavioral errors, cosmetic issues
	-	technical debt - bad / good = reckless (no options to repay, no reason to have) / prudent (options to repay, reason to ship as-is and deal with the consequences)

#### Charts and metrics
##### Story points
- assigned to user stories by the whole development team during the sprint planning meeting
- point is a measure of relative effort required to implement the behavior that the user story represents. This is the inclusive effort required to fulfill the entire software life cycle requirements analysis, technical design, and code implementation with unit testing, plus quality assurance against acceptance criteria and deployment to a staging environment.
- stories can have some time ranges to complete. bigger stories - bigger range (hard to predict the time needed)
##### Velocity
- average sum of story points completed per sprint
- watch out for continuous drops in velocity: they indicate that some serious problems may rise along the way in the next sprints
##### Sprint burndown chart
- graph of story point decrease for a sprint by day
##### Feature burnup chart
the feature burnup chart shows the progress of completed features as they are implemented. At the end of each sprint, it is possible that a new feature might have been implemented in its entirety. The best thing about this graph is that it is impossible to fake the delivery of completed features without having symptoms manifest quite quickly. The idea is to watch this graph increase linearly over time, ideally without significant plateaus.
##### Backlogs
A backlog is a list of pending items that are yet to be addressed. These items are waiting for their time to be taken from the backlog and acted on until they are complete. Each item in the list has an assigned priority and an estimated required effort, and the list is ordered first by priority and then by effort.
###### Product backlog
- features waiting to be implemented & defects that must be fixed but that have not yet been added to a sprint (they also have assigned business value)
- not committed to sprint, but the key representatives of the dev team spent time estimating the effort required - for prioritizing
- priority is primarily dictated by its business value - determined by **product owner**
- the prod. backlog is visible to everyone, so anyone can contribute ideas, offer suggestions
###### Sprint backlog

The sprint backlog contains all of the user stories that are to be completed in the coming sprint. At the start of the sprint, the team selects enough work to fill a sprint based on their current velocity and the relative size of the user stories that are yet to be developed. After the stories are committed to the sprint, the team can start to break down each story into tasks that have real-world time estimates in hours. Each individual then elects to implement enough tasks to fill his or her time during the sprint.

The sprint backlog and all of the time estimates are owned by the team. No one outside of the development team can add items to the sprint backlog, nor can they reliably estimate the relative effort or absolute hours required to complete work. The team alone is responsible for the sprint backlog, but they must take work from the product backlog in priority order.
# Kanban
Locating the bottlenecks and helping relieve them.

a kanban system consists of a big board on the wall with cards or sticky notes placed in columns with numbers at the top.

The cards represent work items as they flow through the development process represented by the columns. The numbers at the top of each column are limits on the number of cards allowed in each column.

The limits are the critical difference between a kanban board and any other visual storyboard. Limiting the amount of work-in-progress (WIP), at each step in the process, prevents overproduction and reveals bottlenecks dynamically so that you can address them before they get out of hand.

# Scrum vs. Kanban applicability
# !!!

# Scrumban
In Scrum, you select the work you’ll be doing for the next sprint beforehand. You then lock the sprint, do all the work, and after a couple of weeks – the usual sprint duration – your queue is empty.
In Kanban, all that’s limited is the size of the queues, called the WIP limit. This means that you can change the items in the queues at any time, and that there’s no “sprint end”. The work just keeps flowing.
Kanban is compatible with Scrum, the project management method. Adding WIP and visualization to Scrum, i.e. Scrumban, helps improve Sprint Commitment effectiveness. However, it is also introduces the WIP limit as a mechanism to catalyze incremental changes.
## When to consider Scrumban

-   Maintenance projects
    -   Event-driven work
    -   Help desk/support
-   Hardening/packaging phases
-   Projects with frequent and unexpected user stories or programming errors
-   Sprint teams focused on new product development
    -   Work preceding sprint development (backlog, R&D)
    -   Work following sprint development (system testing, packaging, and deployment)
-   If Scrum is challenged by workflow issues, resources and processes
-   To manage improvement communities during/after Scrum roll-out

## Scrumban Backlog

-   Avoid creating/analyzing too many stories (requirements/defects) – reduce waste
-   Assure the necessary level of analysis before starting development
-   The backlog should be event-driven with an order point
-   Prioritization-on-demand – the ideal work planning process should always provide the team with best thing to work on next, no more and no less

## Scrumban Board

## 
[![Scrumban board](http://agilealliance.org/wp-content/uploads/2015/10/scrumban-board.jpg)](http://agilealliance.org/wp-content/uploads/2015/10/scrumban-board.jpg)
Kanban vs. Scrumban


[![Kanban vs. Scrumban](http://agilealliance.org/wp-content/uploads/2015/10/kanban-vs-scrumban.jpg)](http://agilealliance.org/wp-content/uploads/2015/10/kanban-vs-scrumban.jpg)


## Scrum vs. Scrumban


[![Scrum vs. Scrumban](http://agilealliance.org/wp-content/uploads/2015/10/scrum-vs-scrumban.jpg)](http://agilealliance.org/wp-content/uploads/2015/10/scrum-vs-scrumban.jpg)






# Estimation

# Scope Concept
**scope** is the defined features and functions of a product, or the scope of work needed to finish a project.
Scope involves getting information required to start a project, and the features the product would have that would meet its stakeholders requirements.
Project scope -> the work required and methods needed
Product scope -> functional requirements
# Estimating
an estimate is a prediction of how long a project will take or how much it will cost. But estimation on software projects interplays with business targets, commitments, and control.
A  _target_  is a statement of a desirable business objective. Examples include the following:
-   "We need to have Version 2.1 ready to demonstrate at a trade show in May."
-   "We need to have this release stabilized in time for the holiday sales cycle."
the fact that a target is desirable or even mandatory does not necessarily mean that it is achievable.

While a target is a description of a desirable business objective, a  _commitment_  is a promise to deliver defined functionality at a specific level of quality by a certain date. A commitment can be the same as the estimate, or it can be more aggressive or more conservative than the estimate. In other words, do not assume that the commitment has to be the same as the estimate; it doesn't.

Tip #1
Distinguish between estimates, targets, and commitments.

Estimation and planning are two different processes: Estimation should be treated as an unbiased, analytical process; planning should be treated as a biased, goal-seeking process.
Both estimation and planning are important, but the fundamental differences between the two activities mean that combining the two tends to lead to poor estimates _and_ poor plans.
Here are examples of planning considerations that depend in part on accurate estimates: Accurate estimates support better work in each of these areas
-   Creating a detailed schedule
-   Identifying a project's critical path
-   Creating a complete work breakdown structure
-   Prioritizing functionality for delivery
-   Breaking a project into iterations

Executives most of the time don't have enough technical background to distinguish between plan and estimate. You role as a tech lead is to find out whether 

Tip #2
When you're asked to provide an estimate, determine whether you're supposed to be estimating or figuring out how to hit a target.
Tip #3
When you see a single-point "estimate," ask whether the number is an estimate or whether it's really a target.
Tip #4
When you see a single-point estimate, that number's probability is not 100%. Ask what the probability of that number is.

Estimates don't need to be perfectly accurate as much as they need to be _useful_. When we have the combination of accurate estimates, good target setting, and good planning and control, we can end up with project results that are close to the "estimates."
_A good estimate is an estimate that provides a clear enough view of the project reality to allow the project leadership to make good decisions about how to control the project to hit its targets_.

## Overestimate or Underestimate
Tip #8
Don't intentionally underestimate. The penalty for underestimation is more severe than the penalty for overestimation. Address concerns about overestimation through planning and control, not by biasing your estimates.
Tip #9
Recognize a mismatch between a project's business target and a project's estimate for what it is: valuable risk information that the project might not be successful. Take corrective action early, when it can do some good.
Tip #10
Many businesses value predictability more than development time, cost, or flexibility. Be sure you understand what your business values the most.

# Decomposition and Recomposition
Decomposition is the practice of separating an estimate into multiple pieces, estimating each piece individually, and then recombining the individual estimates into an aggregate estimate.
Tip #47
Decompose large estimates into small pieces so that you can take advantage of the Law of Large Numbers: the errors on the high side and the errors on the low side cancel each other out to some degree.
Tip #48
Use a generic software-project work breakdown structure (WBS) to avoid omitting common activities.

# Estimation by analogy
**Estimation by Analogy** |   |
| --- | --- |
| **What&#39;s estimated** | Size, Effort, Schedule, Features |
| **Size of project** | S M L |
| **Development stage** | Early-Late |
| **Iterative or sequential** | Both |
| **Accuracy possible** | Medium |
estimation by analogy, which is the simple idea that you can create accurate estimates for a new project by comparing the new project to a similar past project.
Here is a basic estimation by analogy process that will produce better results:
1.  Get detailed size, effort, and cost results for a similar previous project. If possible, get the information decomposed by feature area, by work breakdown structure (WBS) category, or by some other decomposition scheme.
2.  Compare the size of the new project piece-by-piece to the old project.
3.  Build up the estimate for the new project's size as a percentage of the old project's size.
4.  Create an effort estimate based on the size of the new project compared to the size of the previous project.
5.  Check for consistent assumptions across the old and new projects.
   
Tip #53
Estimate new projects by comparing them to similar past projects, preferably decomposing the estimate into at least five pieces.



# Software requirements

# Levels
business requirements

 - high-level objectives of the organization or customer who requests the system;
 - come from the funding sponsor for a project, the acquiring customer, the manager of the actual users; 
 - describe why the organization is implementing the system—the objectives the organization hopes to achieve
 - contained in a vision and scope document

user requirements
- describe user goals or tasks that the users must be able to perform with the product. Valuable ways to represent user requirements include use cases, scenario descriptions, and event-response tables. User requirements therefore describe what the user will be able to do with the system.

functional requirements
- specify the software functionality that the developers must build into the product to enable users to accomplish their tasks, thereby satisfying the business requirements. Sometimes called _behavioral requirements_, these are the traditional "shall" statements: "The system shall e-mail a reservation confirmation to the user."
- documented in a _software requirements specification_ (SRS), which describes as fully as necessary the expected behavior of the software system.

The term _system requirements_ describes the top-level requirements for a product that contains multiple subsystems—that is, a _system_. People are a part of a system, too, so certain system functions might be allocated to human beings.
_Business rules_ include corporate policies, government regulations, industry standards, accounting practices, and computational algorithms.

nonfunctional requirements
- in the srs
- performance goals and descriptions of quality attributes - usability, portability, integrity, efficiency, and robustness
- Other nonfunctional requirements describe external interfaces between the system and the outside world, and design and implementation constraints. _Constraints_ impose restrictions on the choices available to the developer for design and construction of the product.

**Requirements specifications do not include design or implementation details (other than known constraints), project planning information, or testing information** 
Projects typically have other kinds of requirements, including development environment requirements, schedule or budget limitations, the need for a tutorial to help new users get up to speed, or requirements for releasing a product and moving it into the support environment. These are _project_ requirements but not _product_ requirements.

The major consequence of requirements problems is rework—doing over something that you thought was already done. Rework can consume 30 to 50 percent of your total development cost, and requirements errors account for 70 to 85 percent of the rework cost. Shortcomings in requirements practices pose many risks to project success, where _success_ means delivering a product that satisfies the user's functional and quality expectations at agreed-on cost and schedule.
### Insufficient User Involvement
Insufficient user involvement leads to late-breaking requirements that delay project completion
### Creeping User Requirements
To manage scope creep, begin with a clear statement of the project's business objectives, strategic vision, scope, limitations, success criteria, and expected product usage. Evaluate all proposed new features or requirements changes against this reference framework.
### Ambiguous Requirements
a reader can interpret a requirement statement in several ways; multiple readers of a requirement arrive at different understandings of what it means
### Gold Plating
_Gold plating_ takes place when a developer adds functionality that wasn't in the requirements specification but that the developer believes "the users are just going to love." Often users don't care about this excess functionality, and the time spent implementing it is wasted.To reduce the threat of gold plating, trace each bit of functionality back to its origin so that you know why it's included. The use-case approach for eliciting requirements helps to focus requirements elicitation on the functionality that lets users perform their business tasks.

### Minimal Specification
Sometimes marketing staff or managers are tempted to create a limited specification, perhaps just a product concept sketched on a napkin. They expect the developers to flesh out the spec while the project progresses. In most cases, though, it frustrates the developers (who might be operating under incorrect assumptions and with limited direction) and disappoints the customers (who don't get the product they envisioned).
### Overlooked User Classes
Most products have several groups of users who might use different subsets of features, have different frequencies of use, or have varying experience levels. If you don't identify the important user classes for your product early on, some user needs won't be met. After identifying all user classes, make sure that each has a voice
### Inaccurate Planning
Vague, poorly understood requirements lead to overly optimistic estimates, which come back to haunt us when the inevitable overruns occur. An estimator's off-the-cuff guess sounds a lot like a commitment to the listener. When you present an estimate, provide either a range (best case, most likely, worst case) or a confidence level ("I'm 90 percent sure I can have that done within three months").

## Benefits from a High-Quality Requirements Process
-   Fewer requirements defects
-   Reduced development rework
-   Fewer unnecessary features
-   Lower enhancement costs
-   Faster development
-   Fewer miscommunications
-   Reduced scope creep
-   Reduced project chaos
-   More accurate system-testing estimates
-   Higher customer and team member satisfaction

# The Root Causes of Project Success and Failure
three most commonly cited factors that caused projects to be "challenged":
1.  Lack of user input: 13 percent of all projects
2.  Incomplete requirements and specifications: 12 percent of all projects
3.  Changing requirements and specifications: 12 percent of all projects

the three most important "success factors"
1.  User involvement: 16 percent of all successful projects
2.  Executive management support: 14 percent of all successful projects
3.  Clear statement of requirements: 12 percent of all successful projects

Requirements errors are a lot more costly to fix (snowball effect) the later the stage of the project. Also, missed requirements error may not be found, because other stages will be in the way ("perhaps it's a design or a coding error")



# OOD

# OOD
## SOLID
S.O.L.I.D. is a collection of best-practice, object-oriented design principles which can be applied to your design, allowing you to accomplish various desirable goals such as loose-coupling, higher maintainability, intuitive location of interesting code, etc.
### SRP: Single Responsibility Principle 
THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE. 
### OCP: Open Closed Principle 
SOFTWARE ENTITIES (CLASSES, MODULES, FUNCTIONS, ETC.) SHOULD BE OPEN FOR EXTENSION BUT CLOSED FOR MODIFICATION. 
### LSP: Liskov Substitution Principle 
FUNCTIONS THAT USE ... REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT. 
If you have a base class BASE and subclasses SUB1 and SUB2, the rest of your code should always refer to BASE and NOT SUB1 and SUB2.
Violation example: a method, which accepts an IEntity, but has 100 lines of code where this entity is cast to other types and does logic over those types. The method signature states that it works with any IEntity, but it actually doesn't (it works with all of the deriving types instead)

### ISP: Interface Segregation Principle 
CLIENTS SHOULD NOT BE FORCED TO DEPEND UPON INTERFACES THAT THEY DO NOT USE 
if you have an abstract class or an interface, then the implementers should not be forced to implement parts that they don't care about.
### DIP: Dependency Inversion Principle 
A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS 
B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTIONS
Bad designs are:
 Rigid (change affects too many parts of the system) 
 Fragile (every change breaks something unexpected) 
 Immobile (impossible to reuse)

Example:
we have a class with method Encrypt(string input, string output) which takes a file, encrypts it and puts to output path.
A high level Encrypt method, which could be reusable, is now dependent on low-level methods for reading and storing from file. I want to read from database and store to a web service. Problem.


Object-oriented programming is a method of implementation in which programs
are organized as cooperative collections of objects, each of which represents an
instance of some class, and whose classes are all members of a hierarchy of
classes united via inheritance relationships.

Object-oriented design is a method of design encompassing the process of object-
oriented decomposition and a notation for depicting both logical and physical as
well as static and dynamic models of the system under design.

There are two important parts to this definition: object-oriented design (1) leads
to an object-oriented decomposition and (2) uses different notations to express
different models of the logical (class and object structure) and physical (module
and process architecture) design of a system, in addition to the static and dynamic
aspects of the system.
The support for object-oriented decomposition is what makes object-oriented
design quite different from structured design: The former uses class and object
abstractions to logically structure systems, and the latter uses algorithmic abstrac-
tions. We will use the term object-oriented design to refer to any method that
leads to an object-oriented decomposition.

Object-oriented analysis is a method of analysis that examines requirements from
the perspective of the classes and objects found in the vocabulary of the problem
domain.
How are OOA, OOD, and OOP related? Basically, the products of object-oriented
analysis serve as the models from which we may start an object-oriented design; the products of object-oriented design can then be used as blueprints for com-
pletely implementing a system using object-oriented programming methods.

5 kinds of programming style:
1. Procedure-oriented - Algorithms
2. Object-oriented - Classes and objects
3. Logic-oriented - Goals, often expressed in a predicate calculus
4. Rule-oriented - If–then rules
5. Constraint-oriented - Invariant relationships


## Abstraction
An abstraction denotes the essential characteristics of an object that distinguish it
from all other kinds of objects and thus provide crisply defined conceptual
boundaries, relative to the perspective of the viewer.

Entity abstraction An object that represents a useful model of a
problem domain or solution domain entity
■ Action abstraction An object that provides a generalized set of
operations, all of which perform the same
kind of function
■ Virtual machine abstraction An object that groups operations that are all
used by some superior level of control, or
operations that all use some junior-level set
of operations
■ Coincidental abstraction
An object that packages a set of operations
that have no relation to each other

## Encapsulation
Encapsulation is the process of compartmentalizing the elements of an abstrac-
tion that constitute its structure and behavior; encapsulation serves to separate the
contractual interface of an abstraction and its implementation.

Encapsulation in not only data hiding, but also information hiding.
Interface is an abstraction, but putting its implementation into a method without the method knowing its the implementation and not having explicit access to the implementations internal structure is encapsulation.
## Inheritance vs. Aggregation
Hierarchy is a ranking or ordering of abstractions.
inheritance defines a rela-
tionship among classes, wherein one class shares the structure or behavior defined
in one or more classes (denoting single inheritance and multiple inheritance,
respectively). Inheritance thus represents a hierarchy of abstractions, in which a
subclass inherits from one or more superclasses. Typically, a subclass augments
or redefines the existing structure and behavior of its superclasses.

Inheritance = "is a"
Aggregation = "part of"

a garden consists of a
collection of plants together with a growing plan. In other words, plants are “part
of” the garden, and the growing plan is “part of” the garden. This “part of” rela-
tionship is known as aggregation.
## Modularity
Modularity is the property of a system that has been decomposed into a set of
cohesive and loosely coupled modules.
## Polymorphism
Polymorphism is a concept in type theory wherein a name
may denote instances of many different classes as long as they are related by
some common superclass. Any object denoted by this name is thus able to
respond to some common set of operations in different ways. With polymor-
phism, an operation can be implemented differently by the classes in the hierar-
chy. In this manner, a subclass can extend the capabilities of its superclass or
override the parent’s operation
## Abstraction Qualities (cohesion, coupling, etc)
5 metrics to know if class is well designed:
Coupling - the measure of the strength of association established by a
connection from one module to another. Strong coupling complicates a system
since a module is harder to understand, change, or correct by itself if it is highly
interrelated with other modules.

Cohesion - measures the degree of connectivity among the elements of a single module (and
for object-oriented design, a single class or object). Worst cohesion - coincidental; best - functional (a class or module all work together to provide some well-bounded behavior)

Sufficiency - 	the class or module captures enough characteristics of the abstraction to permit
meaningful and efficient interaction. To do otherwise renders the component use-
less. For example, if we are designing the class Set, it is wise to include an oper-
ation that removes an item from the set, but our wisdom is futile if we neglect an
operation that adds an item.

Completeness - the interface of the class or module captures all of the
meaningful characteristics of the abstraction. Whereas sufficiency implies a mini-
mal interface, a complete interface is one that covers all aspects of the abstraction.
A complete class or module is thus one whose interface is general enough to be
commonly usable to any client. Completeness is a subjective matter, and it can be
overdone.

Primitiveness - rimitive operations are those that can be efficiently implemented only if given
access to the underlying representation of the abstraction. Thus, adding an item to
a set is primitive because to implement this operation Add, the underlying repre-
sentation must be visible. On the other hand, an operation that adds four items to
a set is not primitive because it can be implemented just as efficiently on the more
primitive Add operation, without having access to the underlying representation.
Of course, efficiency is also a subjective measure. An operation is indisputably
primitive if we can implement it only through access to the underlying representa-
tion.
## Separation of concerns principle
principle for separating a [computer program](https://en.wikipedia.org/wiki/Computer_program "Computer program") into distinct sections such that each section addresses a separate [concern](https://en.wikipedia.org/wiki/Concern_(computer_science) "Concern (computer science)"). A concern is a set of information that affects the code of a computer program. A concern can be as general as "the details of the hardware for an application", or as specific as "the name of which class to instantiate". A program that embodies SoC well is called a [modular](https://en.wikipedia.org/wiki/Modularity_(programming) "Modularity (programming)") program. Modularity, and hence separation of concerns, is achieved by [encapsulating](https://en.wikipedia.org/wiki/Encapsulation_(computer_science) "Encapsulation (computer science)") information inside a section of code that has a well-defined interface. Encapsulation is a means of [information hiding](https://en.wikipedia.org/wiki/Information_hiding "Information hiding"). Layered designs in information systems are another embodiment of separation of concerns (e.g., presentation layer, business logic layer, data access layer, persistence layer).

## Types vs. Classes
An object's  **class**  defines how the object is implemented .The class defines object's internal state and the implementation of its operations.

In contrast, an object's  **type**  only refers to its interface - a set of requests to which it can respond.

An object can have many types, and objects of different classes can have the same type.

## Design Patterns
### Creational Patterns
These patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.

[Abstract Factory](https://www.dofactory.com/net/abstract-factory-design-pattern)

Creates an instance of several families of classes
Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

![enter image description here](https://www.dofactory.com/images/diagrams/net/abstract.gif)


[Builder](https://www.dofactory.com/net/builder-design-pattern)

Separates object construction from its representation
Separate the construction of a complex object from its representation so that the same construction process can create different representations.

![enter image description here](https://www.dofactory.com/images/diagrams/net/builder.gif)


[Factory Method](https://www.dofactory.com/net/factory-method-design-pattern)

Creates an instance of several derived classes
Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

![enter image description here](https://www.dofactory.com/images/diagrams/net/factory.gif)


[Prototype](https://www.dofactory.com/net/prototype-design-pattern)

A fully initialized instance to be copied or cloned
Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype.

![enter image description here](https://www.dofactory.com/images/diagrams/net/prototype.gif)


[Singleton](https://www.dofactory.com/net/singleton-design-pattern)

A class of which only a single instance can exist
Ensure a class has only one instance and provide a global point of access to it.

![enter image description here](https://www.dofactory.com/images/diagrams/net/singleton.gif)

  

### Structural Patterns

These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.

[Adapter](https://www.dofactory.com/net/adapter-design-pattern)

Match interfaces of different classes
Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

![enter image description here](https://www.dofactory.com/images/diagrams/net/adapter.gif)


[Bridge](https://www.dofactory.com/net/bridge-design-pattern)

Separates an object’s interface from its implementation
Decouple an abstraction from its implementation so that the two can vary independently.

![enter image description here](https://www.dofactory.com/images/diagrams/net/bridge.gif)


[Composite](https://www.dofactory.com/net/composite-design-pattern)

A tree structure of simple and composite objects
Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

![enter image description here](https://www.dofactory.com/images/diagrams/net/composite.gif)


[Decorator](https://www.dofactory.com/net/decorator-design-pattern)

Add responsibilities to objects dynamically
Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

![enter image description here](https://www.dofactory.com/images/diagrams/net/decorator.gif)


[Facade](https://www.dofactory.com/net/facade-design-pattern)

A single class that represents an entire subsystem
Provide a unified interface to a set of interfaces in a subsystem. Façade defines a higher-level interface that makes the subsystem easier to use.


![enter image description here](https://www.dofactory.com/images/diagrams/net/facade.gif)


[Flyweight](https://www.dofactory.com/net/flyweight-design-pattern)

A fine-grained instance used for efficient sharing
Use sharing to support large numbers of fine-grained objects efficiently.

![enter image description here](https://www.dofactory.com/images/diagrams/net/flyweight.gif)


[Proxy](https://www.dofactory.com/net/proxy-design-pattern)

An object representing another object
Provide a surrogate or placeholder for another object to control access to it.

![enter image description here](https://www.dofactory.com/images/diagrams/net/proxy.gif)

  

### Behavioral Patterns
These patterns are concerned with algorithms and the assignment of responsibilities between objects.

[Chain of Resp.](https://www.dofactory.com/net/chain-of-responsibility-design-pattern)

A way of passing a request between a chain of objects
Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.


![enter image description here](https://www.dofactory.com/images/diagrams/net/chain.gif)


[Command](https://www.dofactory.com/net/command-design-pattern)

Encapsulate a command request as an object
Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.

![enter image description here](https://www.dofactory.com/images/diagrams/net/command.gif)


[Interpreter](https://www.dofactory.com/net/interpreter-design-pattern)

A way to include language elements in a program
Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.

![enter image description here](https://www.dofactory.com/images/diagrams/net/interpreter.gif)


[Iterator](https://www.dofactory.com/net/iterator-design-pattern)

Sequentially access the elements of a collection
Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

![enter image description here](https://www.dofactory.com/images/diagrams/net/iterator.gif)


[Mediator](https://www.dofactory.com/net/mediator-design-pattern)

Defines simplified communication between classes
Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.

![enter image description here](https://www.dofactory.com/images/diagrams/net/mediator.gif)


[Memento](https://www.dofactory.com/net/memento-design-pattern)

Capture and restore an object's internal state
Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later.

![enter image description here](https://www.dofactory.com/images/diagrams/net/memento.gif)


[Observer](https://www.dofactory.com/net/observer-design-pattern)

A way of notifying change to a number of classes
Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

![enter image description here](https://www.dofactory.com/images/diagrams/net/observer.gif)

-   **Subject** **(Stock)**
    -   knows its observers. Any number of Observer objects may observe a subject
    -   provides an interface for attaching and detaching Observer objects.
-   **ConcreteSubject** **(IBM)**
    -   stores state of interest to ConcreteObserver
    -   sends a notification to its observers when its state changes
-   **Observer** **(IInvestor)**
    -   defines an updating interface for objects that should be notified of changes in a subject.
-   **ConcreteObserver** **(Investor)**
    -   maintains a reference to a ConcreteSubject object
    -   stores state that should stay consistent with the subject's
    -   implements the Observer updating interface to keep its state consistent with the subject's

[State](https://www.dofactory.com/net/state-design-pattern)

Alter an object's behavior when its state changes
Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.

![enter image description here](https://www.dofactory.com/images/diagrams/net/state.gif)


[Strategy](https://www.dofactory.com/net/strategy-design-pattern)

Encapsulates an algorithm inside a class
Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

![enter image description here](https://www.dofactory.com/images/diagrams/net/strategy.gif)


[Template Method](https://www.dofactory.com/net/template-method-design-pattern)

Defer the exact steps of an algorithm to a subclass
Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.

![enter image description here](https://www.dofactory.com/images/diagrams/net/template.gif)


[Visitor](https://www.dofactory.com/net/visitor-design-pattern)

Defines a new operation to a class without change
Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.

![enter image description here](https://www.dofactory.com/images/diagrams/net/visitor.gif)


### Repository
A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection. Client objects construct query specifications declaratively and submit them to Repository for satisfaction. Objects can be added to and removed from the Repository, as they can from a simple collection of objects, and the mapping code encapsulated by the Repository will carry out the appropriate operations behind the scenes. Conceptually, a Repository encapsulates the set of objects persisted in a data store and the operations performed over them, providing a more object-oriented view of the persistence layer. Repository also supports the objective of achieving a clean separation and one-way dependency between the domain and data mapping layers.

![enter image description here](https://martinfowler.com/eaaCatalog/repositorySketch.gif)

### Service locator pattern
The service locator pattern is a design pattern used in software development to encapsulate the processes involved in obtaining a service with a strong abstraction layer. This pattern uses a central registry known as the “service locator” which on request returns the information necessary to perform a certain task.  
The ServiceLocator is responsible for returning instances of services when they are requested for by the service consumers or the service clients.

![enter image description here](https://media.geeksforgeeks.org/wp-content/uploads/dPattern.jpg)

+simplifies component-based systems (alternative to DI)
-obscures dependencies

### Unit of work
Unit of Work is referred to as a single transaction that involves multiple operations of insert/update/delete and so on kinds. To say it in simple words, it means that for a specific user action (say registration on a website), all the transactions like insert/update/delete and so on are done in one single transaction, rather then doing multiple database transactions. This means, one unit of work here involves insert/update/delete operations, all in one single transaction.

### Rules pattern ?
The Rules Pattern works by separating out the rules from the rules processing logic (applying the [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle)). This makes it easy to add new rules without changing the rest of the system

![enter image description here](https://www.michael-whelan.net/images/rules-pattern.png)

With the Rules Pattern there is an Evaluator class that loops through a collection of rules and executes them. It evaluates the result and decides what action to take. In the simplest case it just executes all the rules, but it is also possible to add some selection logic to each rule that allows the Evaluator class to decide whether or not to run the rule (such as the IsMatch() method on the IRule interface above).
### Specification pattern
the **specification pattern** is a particular [software design pattern](https://en.wikipedia.org/wiki/Software_design_pattern "Software design pattern"), whereby [business rules](https://en.wikipedia.org/wiki/Business_rules "Business rules") can be recombined by chaining the business rules together using boolean logic. The pattern is frequently used in the context of [domain-driven design](https://en.wikipedia.org/wiki/Domain-driven_design).

![enter image description here](https://upload.wikimedia.org/wikipedia/commons/8/8b/Specification_UML_v2.png)


### Event aggregator
Channel events from multiple objects into a single object to simplify registration for clients.

![enter image description here](https://martinfowler.com/eaaDev/eventAggregator/objects.gif)

In its simplest form you have it register with all the source objects you are interested in, and have all target objects register with the  Event Aggregator. The  Event Aggregator  responds to any event from a source object by propagating that event to the target objects.

The simplest  Event Aggregator  aggregates events from multiple objects into itself, passing that same event onto its observers.

Event Aggregator is a good choice when you have lots of objects that are potential event sources. Rather than have the observer deal with registering with them all, you can centralize the registration logic to the Event Aggregator. As well as simplifying registration, a Event Aggregator also simplifies the memory management issues in using observers.

### Lazy Loading
Lazy loading is a concept where we delay the loading of object until the point where we need it.
**There are four common implementations of Lazy Loading pattern :**
1.  Virtual proxy - Virtual Proxy is an object with the same interface as the real object. The first time one of its methods is called it loads the real object and then delegates.
2.  Lazy initialization - With lazy initialization, the object to be lazily loaded is originally set to null, and every request for the object checks for null and creates it "on the fly" before returning it first
3.  Ghost - A "ghost" is the object that is to be loaded in a partial state. It may only contain the object's identifier, but it loads its own data the first time one of its properties is accessed.
4.  Value holder - A _value holder_ is a generic object that handles the lazy loading behavior, and appears in place of the object's data fields

### MVP (Model-View-Presenter)
is a derivation of the  [model–view–controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller "Model–view–controller")  (MVC)  [architectural pattern](https://en.wikipedia.org/wiki/Architectural_pattern "Architectural pattern"), and is used mostly for building user interfaces.

In MVP, the  _presenter_  assumes the functionality of the "middle-man". In MVP, all presentation logic is pushed to the presenter.

is a user interface  [architectural pattern](https://en.wikipedia.org/wiki/Architectural_pattern_(computer_science) "Architectural pattern (computer science)")  engineered to facilitate  [automated](https://en.wikipedia.org/wiki/Test_automation "Test automation")  [unit testing](https://en.wikipedia.org/wiki/Unit_testing "Unit testing")  and improve the  [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns "Separation of concerns")  in presentation logic:

-   The  _model_  is an interface defining the data to be displayed or otherwise acted upon in the user interface.
-   The  _view_  is a passive interface that displays data (the model) and routes user commands ([events](https://en.wikipedia.org/wiki/Event_(computing) "Event (computing)")) to the presenter to act upon that data.
-   The  _presenter_  acts upon the model and the view. It retrieves data from repositories (the model), and formats it for display in the view.

Normally, the view implementation  [instantiates](https://en.wikipedia.org/wiki/Instance_(computer_science) "Instance (computer science)")  the concrete presenter object, providing a reference to itself.

### MVVM
**Model–view–viewmodel**  (**MVVM**) is a software  [architectural pattern](https://en.wikipedia.org/wiki/Architectural_pattern "Architectural pattern").

MVVM facilitates a  [separation](https://en.wikipedia.org/wiki/Separation_of_concerns "Separation of concerns")  of development of the  [graphical user interface](https://en.wikipedia.org/wiki/Graphical_user_interface "Graphical user interface")  – be it via a  [markup language](https://en.wikipedia.org/wiki/Markup_language "Markup language")  or GUI code – from development of the  [business logic](https://en.wikipedia.org/wiki/Business_logic "Business logic")  or  [back-end](https://en.wikipedia.org/wiki/Front_and_back_ends "Front and back ends")  logic (the  _data model_). The  _view model_  of MVVM is a value converter,  meaning the view model is responsible for exposing (converting) the  [data objects](https://en.wikipedia.org/wiki/Data_object "Data object")  from the model in such a way that objects are easily managed and presented. In this respect, the view model is more model than view, and handles most if not all of the view's display logic.  The view model may implement a  [mediator pattern](https://en.wikipedia.org/wiki/Mediator_pattern "Mediator pattern"), organizing access to the back-end logic around the set of  [use cases](https://en.wikipedia.org/wiki/Use_case "Use case")  supported by the view.

![enter image description here](https://upload.wikimedia.org/wikipedia/commons/8/87/MVVMPattern.png)


Model

_Model_  refers either to a  [domain model](https://en.wikipedia.org/wiki/Domain_model "Domain model"), which represents real state content (an object-oriented approach), or to the  [data access layer](https://en.wikipedia.org/wiki/Data_access_layer "Data access layer"), which represents content (a data-centric approach).[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_]

View

As in the  [model-view-controller](https://en.wikipedia.org/wiki/Model-view-controller "Model-view-controller")  (MVC) and  [model-view-presenter](https://en.wikipedia.org/wiki/Model-view-presenter "Model-view-presenter")  (MVP) patterns, the  _view_  is the structure, layout, and appearance of what a user sees on the screen.  It displays a representation of the model and receives the user's interaction with the view (clicks, keyboard, gestures, etc.), and it forwards the handling of these to the view model via the  [data binding](https://en.wikipedia.org/wiki/Data_binding "Data binding")  (properties, event callbacks, etc.) that is defined to link the view and view model.

View model

The  _view model_  is an abstraction of the view exposing public properties and commands. Instead of the controller of the MVC pattern, or the presenter of the MVP pattern, MVVM has a  _binder_, which automates communication between the view and its bound properties in the view model. The view model has been described as a state of the data in the model.

The main difference between the view model and the Presenter in the MVP pattern, is that the presenter has a reference to a view whereas the view model does not. Instead, a view directly binds to properties on the view model to send and receive updates. To function efficiently, this requires a binding technology or generating  [boilerplate code](https://en.wikipedia.org/wiki/Boilerplate_code "Boilerplate code")  to do the binding.

### Null object pattern
The Null object pattern is a design pattern that simplifies the use of dependencies that can be undefined. This is achieved by using instances of a concrete class that implements a known interface, instead of null references.  
We create an abstract class specifying various operations to be done, concrete classes extending this class and a null object class providing do nothing implementation of this class and will be used seamlessly where we need to check null value.

![enter image description here](https://media.geeksforgeeks.org/wp-content/uploads/NullObject.png)


## Architectural software patterns
### Layered architecture
n-tier, where each layer is grouped by a specific role and responsibility within the application

![enter image description here](https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0101.png)

One of the powerful features of the layered architecture pattern is the _separation of concerns_ among components. Components within a specific layer deal only with logic that pertains to that layer.

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0103.png)

A layer is closed if a request cannot jump over it to a lower layer.

be wary of _architecture sinkhole anti-pattern_ - when most of the requests are just data retrieval without any modification, but still have to pass through all the layers
**Overall agility** - low - because it tends to be more monolithic and tightly coupled
**Ease of deployment** - low - depends on how is developed - could require a full redeployment for small change
**Testability** - high - components are bound to a specific layer, and other layers can be mocked or stubbed
**Performance** - low - some might be good, but most of the time a business request has to pass through all layers, which is time consuming
**Scalability** - low - this pattern is popular in monolithic and tightly coupled apps; scaling can be achieved by splitting layers into separate physical deployments or replication, but the granularity is too low;
**Ease of development** - high - _Conway’s law_; it's popular and relatively easy to understand
### Event-Driven Architecture
- popular distributed asynchronous architecture pattern used to produce highly scalable applications
- highly adaptable and can be used for small applications and as well as large, complex ones
- made up of highly decoupled, single-purpose event processing components that asynchronously receive and process events

Consists of two main topologies, the mediator and the broker. The mediator topology is commonly used when you need to orchestrate multiple steps within an event through a central mediator, whereas the broker topology is used when you want to chain events together without the use of a central mediator.
#### Mediator Topology
The mediator topology is useful for events that have multiple steps and require some level of orchestration to process the event. For example, a single event to place a stock trade might require you to first validate the trade, then check the compliance of that stock trade against various compliance rules, assign the trade to a broker, calculate the commission, and finally place the trade with that broker. All of these steps would require some level of orchestration to determine the order of the steps and which ones can be done serially and in parallel.
Architecture components:
- event queues - used to transport the event to the event mediator
- event mediator - receives the initial event and orchestrates that event by sending additional asynchronous events to _event channels_
- event channels - execute each step of the process
- event processors - listen on the event channels, receive the event from the event mediator and execute specific business logic to process the event.

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0201.png)


2 types of events:
- initial event - original event received by the mediator
- processing event - are generated by the mediator and received by the event-processing components.

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0202.png)


#### Broker topology
- there is no central event mediator; rather, the message flow is distributed across the event processor components in a chain-like fashion through a lightweight message broker
- useful when you have a relatively simple event processing flow and you do not want (or need) central event orchestration.
Architecture components:
- _broker_ - can be centralized or federated and contains all of the event channels that are used within the event flow. The event channels contained within the broker component can be message queues, message topics, or a combination of both.
- _event processor_

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0203.png)


![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0204.png)


you must address various distributed architecture issues, such as remote process availability, lack of responsiveness, and broker reconnection logic in the event of a broker or mediator failure.
lack of atomic transactions for a single business process.
**Overall agility** - high - changes are generally isolated to one or a few event processors because event-processor components are single-purpose and completely decoupled from other event processor components
**Ease of  deployment**- high - easy to deploy because of decoupling; broker topology tends to be easier to deploy than the mediator topology, primarily because the event mediator component is somewhat tightly coupled to the event processors: a change in an event processor component might also require a change in the event mediator, requiring both to be deployed for any given change.
**Testability**-low - because of async and requires specialized testing client or tool
**Performance**-high - parallel asynchronous
**Scalability** - high - hrough highly independent and decoupled event processors. Each event processor can be scaled separately, allowing for fine-grained scalability.
**Ease of  development** - low - asynchronous nature of the pattern as well as contract creation and the need for more advanced error handling conditions within the code for unresponsive event processors and failed brokers.

### Microkernel Architecture
- natural pattern for implementing product-based applications(packaged and made available for download in versions as a typical third-party product)
- allows you to add additional application features as plug-ins to the core application, providing extensibility as well as feature separation and isolation.

Architecture components:
- _core system_ -traditionally contains only the minimal functionality required to make the system operational.
- _plug-in modules_ - stand-alone, independent components that contain specialized processing, additional features, and custom code that is meant to enhance or extend the core system to produce additional business capabilities (can depend on other plug-ins, but is not recommended)
Application logic is divided between independent plug-in modules and the basic core system, providing extensibility, flexibility, and isolation of application features and custom processing logic.
![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0301.png)

The core system needs to know about which plug-in modules are available and how to get to them - registry

- it can be embedded or used as part of another architecture pattern
- great support for evolutionary design and incremental development. You can first produce a solid core system, and as the application evolves incrementally, add features and functionality without having to make significant changes to the core system.
- For product-based applications, the microkernel architecture pattern should always be your first choice as a starting architecture, particularly for those products where you will be releasing additional features over time and want control over which users get which features
**Overall  agility** - high - core quickly becomes stable, so is fairly robust and requires little change over time (doesn't subtract from agility) & loosely coupled modules isolate changes
**Ease of  deployment** - high - depending on how it is implemented: plug-ins can be how-deployed, dynamically added
**Testability** - high - Plug-in modules can be tested in isolation and can be easily mocked by the core system to demonstrate or prototype a particular feature with little or no change to the core system.
**Performance** - high - in general perform well, because you set plug-ins which you need
**Scalability** - low - most microkernel architecture implementations are product based and are generally smaller in size, they are implemented as single units and hence not highly scalable. Depending on how you implement the plug-in modules, you can sometimes provide scalability at the plug-in feature level, but overall this pattern is not known for producing highly scalable applications.
**Ease of  development** - low - requires thoughtful design and contract governance, making it rather complex to implement. Contract versioning, internal plug-in registries, plug-in granularity, and the wide choices available for plug-in connectivity all contribute to the complexity involved with implementing this pattern.
### Microservices
_separately deployed units_ - each component of the microservices architecture is deployed as a separate unit, allowing for easier deployment through an effective and streamlined delivery pipeline, increased scalability, and a high degree of application and component decoupling within your application.
_service component_ - contain one or more modules (e.g., Java classes) that represent either a single-purpose function (e.g., providing the weather for a specific city or town) or an independent portion of a large business application (e.g., stock trade placement or determining auto-insurance rates). Designing the right level of service component granularity is one of the biggest challenges within a microservices architecture.

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0401.png)


_distributed_ architecture - all the components within the architecture are fully decoupled from one other and accessed through some sort of remote access protocol (e.g., JMS, AMQP, REST, SOAP, RMI, etc.). The distributed nature of this architecture pattern is how it achieves some of its superior scalability and deployment characteristics.
#### Topologies
##### _API REST-based_ topology
- useful for websites that expose small, self-contained individual services through some sort of API
- consists of very fine-grained service components (hence the name _microservices_) that contain one or two modules that perform specific business functions independent from the rest of the services
- these fine-grained service components are typically accessed using a REST-based interface implemented through a separately deployed web-based API layer

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0402.png)

##### _application REST-based_ topology
- client requests are received through traditional web-based or fat-client business application screens rather than through a simple API layer
- the user-interface layer of the application is deployed as a separate web application that remotely accesses separately deployed service components (business functionality) through simple REST-based interfaces
- difference from REST API based topology: service components tend to be larger, more coarse-grained, and represent a small portion of the overall business application rather than fine-grained, single-action services
- common for small to medium-sized business applications that have a relatively low degree of complexity.

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0403.png)


##### _centralized messaging_ topology
- instead of using REST for remote access, this topology uses a lightweight centralized message broker (e.g., ActiveMQ, HornetQ, etc.)
- not to confuse it with the service-oriented architecture pattern or consider it “SOA-Lite." The lightweight message broker found in this topology does not perform any orchestration, transformation, or complex routing; rather, it is just a lightweight transport to access remote service components.
- typically found in larger business applications or applications requiring more sophisticated control over the transport layer between the user interface and the service components
- benefits over the REST-based topology: advanced queuing mechanisms, asynchronous messaging, monitoring, error handling, and better overall load balancing and scalability
- The single point of failure and architectural bottleneck issues usually associated with a centralized broker are addressed through broker clustering and broker federation (splitting a single broker instance into multiple broker instances to divide the message throughput load based on functional areas of the system).

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_0404.png)


#### Considerations
- find the grain of your service components: too fine-grained will lead to a lot of inter-service requests, too coarse-grained will lead to worse deployments and testability (some apps can have shared db between some microservices to reduce requests, or can duplicate some of the functionality between service components in order to make them less coupled)
-  major application components are split up into smaller, separately deployed units, applications built using the microservices architecture pattern are generally more robust, provide better scalability, and can more easily support continuous delivery.
- provides the capability to do real-time production deployments, thereby significantly reducing the need for the traditional monthly or weekend “big bang” production deployments.
- is a distributed architecture, it shares some of the same complex issues found in the event-driven architecture pattern, including contract creation, maintenance, and government, remote system availability, and remote access authentication and authorization.
**Overall  agility**-high-separately deployed units, change is generally isolated to individual service components, which allows for fast and easy deployment. Also, applications build using this pattern tend to be very loosely coupled, which also helps facilitate change.
**Ease  of  deployment**-high-fine-grained and independent nature of the remote services. Services are generally deployed as separate units of software, resulting in the ability to do “hot deployments” any time during the day or night. Overall deployment risk is also significantly reduced, in that failed deployments are able to be restored more quickly and only impact the operations on the service being deployed, resulting in continued operations for all other operations
**Testability**-high-Due to the separation and isolation of business functionality into independent applications, testing can be scoped, allowing for more targeted testing efforts. Regression testing for a particular service component is much easier and more feasible than regression testing for an entire monolithic application. Also, since the service components in this pattern are loosely coupled, there is much less of a chance from a development perspective of making a change that breaks another part of the application, easing the testing burden of having to test the entire application for one small change.
**Performance**-low-overall this pattern does not naturally lend itself to high-performance applications due to the distributed nature of the microservices architecture pattern.
**Scalability**-high-application is split into separately deployed units, each service component can be individually scaled, allowing for fine-tuned scaling of the application
**Ease of  development**-high - Because functionality is isolated into separate and distinct service components, development becomes easier due to the smaller and isolated scope. There is much less chance a developer will make a change in one service component that would affect other service components, thereby reducing the coordination needed among developers or development teams.
### Architectures rating

![enter image description here](https://learning.oreilly.com/library/view/software-architecture-patterns/9781491971437/assets/sapr_aa01.png)


## Inversion of Control Containers and the Dependency Injection pattern
**IoC**  is a generic term meaning rather than having the application call the methods in a framework, the framework calls implementations provided by the application.

**DI**  is a form of IoC, where implementations are passed into an object through constructors/setters/service lookups, which the object will 'depend' on in order to behave correctly.

**IoC without using DI**, for example would be the Template pattern because the implementation can only be changed through sub-classing.

**DI Frameworks**  are designed to make use of DI and can define interfaces (or Annotations in Java) to make it easy to pass in the implementations.

**IoC Containers**  are DI frameworks that can work outside of the programming language. In some you can configure which implementations to use in metadata files (e.g. XML) which are less invasive. With some you can do IoC that would normally be impossible like inject an implementation at  [pointcuts](http://en.wikipedia.org/wiki/Pointcut).

Inversion of Control (also known as the Hollywood Principle - "Don't call us, we'll call you") - rather than you calling some code of a library (code which you call and get a result), the framework (code, where you plug in your own behavior or code and it calls it for you) calls your code (via events, delegates etc.). Not to be confused with IoC Containers!
The basic idea of the Dependency Injection is to have a separate object, an assembler, that populates a field in the lister class with an appropriate implementation for the finder interface

![enter image description here](https://martinfowler.com/articles/injection/injector.gif)

Forms of DI:
- Constructor Injection - provide dependencies in constructor of the dependent object
- Setter Injection - via properties (setters)
- Interface Injection - define an interface, which means "I need _this_ dependency injected" (e.g. via method which accepts the dependency); the type with the dependency implements the interface - the config of what and how to inject with that interface is handled via the DI framework (code, xml etc.)

## DDD
Domain-Driven Design is an approach to the development of complex software in which we: 
1. Focus on the core domain. 
2. Explore models in a creative collaboration of domain practitioners and software practitioners. 
3.  Speak a ubiquitous language within an explicitly bounded context.
**domain** A sphere of knowledge, influence, or activity. The subject area to which the user applies a program is the domain of the software. 
**model** A system of abstractions that describes selected aspects of a domain and can be used to solve problems related to that domain. 
**ubiquitous language** A language structured around the domain model and used by all team members within a bounded context to connect all the activities of the team with the software. 
**context** The setting in which a word or statement appears that determines its meaning. Statements about a model can only be understood in a context. 
**bounded context** A description of a boundary (typically a subsystem, or the work of a particular team) within which a particular model is defined and applicable.

Why Care about DDD?
4. principles and patterns to solve difficult problems
5. history of success with complex projects
6. aligns with practices from experience
7. clear, testable code that represents the domain

Pros:
- flexible
- close to customer's vision /perspective of the problem
- path through a very complex problem
- well-organized and easily tested code
- business logic lives in one place
- many great patterns to leverage
DDD is best suited for problems in a complex domain, where domain experts have difficulties telling their needs to the developers.

Cons:
 - time & effort
	- discuss & model the problem with domain experts
	- isolate domain logic from other parts of application (infrastructure)
 - learning curve 
	- new principles, patterns and processes
 - only makes sense when there's complexity in the problem
	- not just technical complexity without business domain complexity
	- not just CRUD or data-driven apps
 - team or company buy in to DDD

![enter image description here](https://vladikk.com/images/ddd/ddd-patterns.png)


**Sub-domain**
  Some parts of the model add complexity without capturing or communicating specialized knowledge. They make the core domain more complex, but are necessary to the system and the full expression of the model.
  Identify cohesive subdomains that are not the motivation for your project. Factor out generic models of these subdomains and place them in separate modules. Leave no trace of your specialties in them. 
  Once they have been separated, give their continuing development lower priority than the core domain, and avoid assigning your core developers to the tasks (because they will gain little domain knowledge from them). Also consider off-the-shelf solutions or published models for these generic subdomains.
 **Bounded Context**
  Explicitly define the context within which a model applies. Explicitly set boundaries in terms of team organization, usage within specific parts of the application, and physical manifestations such as code bases and database schemas. Apply Continuous Integration to keep model concepts and terms strictly consistent within these bounds, but don’t be distracted or confused by issues outside. Standardize a single development process within the context, which need not be used elsewhere.
 **Difference Between Sub-domain and Bounded Context**
  Think of an e-Commerce system. Initially you can tell it is an application of shopping context. But if you look more closely, you will see there are other contexts too. Like: Inventory, Delivery, Accounts etc.
**Understanding Context Maps**
  To plot strategy, we need a realistic, large-scale view of model development extending across our project and others we integrate with.
Identify each model in play on the project and define its bounded context. This includes the implicit models of non-object-oriented subsystems. Name each bounded context, and make the names part of the ubiquitous language. 
Describe the points of contact between the models, outlining explicit translation for any communication, highlighting any sharing, isolation mechanisms, and levels of influence. 
Map the existing terrain. Take up transformations later.
This map can be a basis for realistic design strategy.
 **The Ubiquitous Language of a Bounded Context**
 One language within a context for a model for everyone: domain experts, devs etc.
  Use the model as the backbone of a language. Commit the team to exercising that language relentlessly in all communication within the team and in the code. Within a bounded context, use the same language in diagrams, writing, and especially speech. Recognize that a change in the language is a change to the model. Iron out difficulties by experimenting with alternative expressions, which reflect alternative models. Then refactor the code, renaming classes, methods, and modules to conform to the new model. Resolve confusion over terms in conversation, in just the way we come to agree on the meaning of ordinary words.
**Anemic and Rich Models**
  In an Anemic Domain Model:
-   The  **domain objects**  (also called  **models**) are only pure data structures. Almost no logic is implemented there.
-   The  **services**  set model’s properties via setters and define the logic of your application.

With the Rich Domain Model:
-   All the domain logic is implemented in  **real domain objects**
-   The  **service layer**  is thin and used only for third party services.
The domain objects deal with the data _and_ the domain logic.

**Entities in DDD and in Our Bounded Context**
  The key defining characteristic of an Entity is that it has an Identity – it is unique within the system, and no other Entity, no matter how similar is, the same Entity unless it has the same Identity.
 Examples:
1.  Your bed room in the apartment.
2.  Contract in Facebook.
3.  Article in CodeProject.
**Value Objects**
  The key defining characteristic of a Value Object is it has no Identity. Ok, perhaps a little simplistic, but the intention of a Value Object is to represent something by its attributes only. Two value objects may have identical attributes, in which case they are identical. They don’t however have any value other than by virtue of their attributes. Another aspect common to value objects is that they should probably be immutable, once created they cannot be changed or altered. You can create a new one, and as they have no identity, that is just the same as changing another one.  

### Example:

1.  Windows in the rooms
2.  Address of any person in your website.
3.  SearchCriteria of your search.

`**Note:**  A value object can become an entity depending on the situation. Can you find a scenario like that? If the requirement of the search functionality of your application says that, the search criteria should be saved in the database and the user can do the same search from the list of saved search criteria’s. In this scenario SearchCriteria has its own identity and thus it is an entity instead of being a value object.`
**Domain Services**
  If Entities and Value Objects are the “things” in your domain, the services are a way of dealing with actions, operations and activities.
Shouldn’t Logic Be on the Entities Directly?

Yes, it really should. We should be modeling our Entities with the logic that relates to them and their children. But, there are occasions when we need to deal with complex operations or external responsibilities or maybe we need to expose the actions of the aggregate roots to the external world. This is why creating a domain service for different aggregate root is a good idea. You can consider the domain services as façade layer of the business logics and operations of your domain.
**Aggregates and Aggregate Roots**
  In domain driven design entities and value objects can exist independently. But in some cases the relation can be such that, an entity or VO has no value without its context.

### Example:

1.  A window can only be defined if there is a room.
2.  An order note can only exist if an order is placed.
3.  A question detail can only be there if a question is asked.
-   Room, Order and Question are our aggregate roots.
-   On the other hand window, order note and question detail are our aggregates.

“A cluster of associated objects that are treated as a unit with regard to data changes.”  
All objects of the clusters should be treated as aggregate.  
All external access to the cluster is through a single root Entity. This root entity is defined as aggregate root.

### Example:

1.  A question detail should no way be saved unless the corresponding question is saved.
2.  A question detail should no way be retrieved unless the corosponding question is retrieved.

Here Question is the Aggregate root and Question Detail is the aggregate.
**Repositories**
  Persistence Ignorance
  You do not need to know how and where the data of your domain will persist or even if the data do need to persist while you do the model of the domain. In a real application you do need to have a database. But your domain model will have no knowledge about that. All it will know is the “Repository” which will eventually manage your application’s persistence concern.
your domain model will not know any database. What it will know is, there is a repository in the system and that repository will be responsible to store your data and to retrieve your data. It is no way a concern of your domain model how and where data will persist. So, it can be Sql server, oracle, xml, text file or anything else.

Repository Mediates between the domain and data mapping using a collection-like interface for accessing domain objects. It is more like a facade to your data store that pretend like a collection of your domain.

`Repository Is Not A Data Access Layer.`

Note that repository doesn’t talk in terms of “data”, it talks in terms of Aggregate Roots. You can tell your repository to add an Aggregate Root into its collection, or you can ask it for a particular Aggregate Root. When you remember that Aggregate Roots may comprise one or many Entities and Value Objects, this makes it fairly different to a traditional DAL that returns you back a set of rows from your database tables.
 **Domain Events**
Something happened that domain experts care about.
An entity is responsible for tracking its state and the rules regulating its lifecycle. But if you need to know the actual causes of the state changes, this is typically not explicit, and it may be difficult to explain how the system got the way it is.
Model information about activity in the domain as a series of discrete events. Represent each event as a domain object. These are distinct from system events that reflect activity within the software itself, although often a system event is associated with a domain event, either as part of a response to the domain event or as a way of carrying information about the domain event into the system. A domain event is a full-fledged part of the domain model, a representation of something that happened in the domain. Ignore irrelevant domain activity while making explicit the events that the domain experts want to track or be notified of, or which are associated with state change in the other model objects.

# Anti-pattern
An **anti-pattern** is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive.
### [Software Development AntiPatterns](https://sourcemaking.com/antipatterns/software-development-antipatterns)
-   [The Blob](https://sourcemaking.com/antipatterns/the-blob)  
    Procedural-style design leads to one object with a lion’s share of the responsibilities, while most other objects only hold data or execute simple processes. The solution includes refactoring the design to distribute responsibilities more uniformly and isolating the effect of changes.
-   [Continuous Obsolescence](https://sourcemaking.com/antipatterns/continuous-obsolescence)  
    Technology is changing so rapidly that developers often have trouble keeping up with current versions of software and finding combinations of product releases that work together. Given that every commercial product line evolves through new releases, the situation is becoming more difficult for developers to cope with. Finding compatible releases of products that successfully interoperate is even harder.
-   [Lava Flow](https://sourcemaking.com/antipatterns/lava-flow)  
    Dead code and forgotten design information is frozen in an ever-changing design. This is analogous to a Lava Flow with hardening globules of rocky material. The refactored solution includes a configuration management process that eliminates dead code and evolves or refactors design toward increasing quality.
-   [Ambiguous Viewpoint](https://sourcemaking.com/antipatterns/ambiguous-viewpoint)  
    Object-oriented analysis and design (OOA&D) models are often presented without clarifying the viewpoint represented by the model. By default, OOA&D models denote an implementation viewpoint that is potentially the least useful. Mixed viewpoints don’t allow the fundamental separation of interfaces from implementation details, which is one of the primary benefits of the object-oriented paradigm.
-   [Functional Decomposition](https://sourcemaking.com/antipatterns/functional-decomposition)  
    This AntiPattern is the output of experienced, nonobject-oriented developers who design and implement an application in an object-oriented language. The resulting code resembles a structural language (Pascal, FORTRAN) in class structure. It can be incredibly complex as smart procedural developers devise very “clever” ways to replicate their time-tested methods in an object-oriented architecture.
-   [Poltergeists](https://sourcemaking.com/antipatterns/poltergeists)  
    Poltergeists are classes with very limited roles and effective life cycles. They often start processes for other objects. The refactored solution includes a reallocation of responsibilities to longer-lived objects that eliminate the Poltergeists.
-   [Boat Anchor](https://sourcemaking.com/antipatterns/boat-anchor)  
    A Boat Anchor is a piece of software or hardware that serves no useful purpose on the current project. Often, the Boat Anchor is a costly acquisition, which makes the purchase even more ironic.
-   [Golden Hammer](https://sourcemaking.com/antipatterns/golden-hammer)  
    A Golden Hammer is a familiar technology or concept applied obsessively to many software problems. The solution involves expanding the knowledge of developers through education, training, and book study groups to expose developers to alternative technologies and approaches.
-   [Dead End](https://sourcemaking.com/antipatterns/dead-end)  
    A Dead End is reached by modifying a reusable component if the modified component is no longer maintained and supported by the supplier. When these modifications are made, the support burden transfers to the application system developers and maintainers. Improvements in the reusable component are not easily integrated, and support problems can be blamed upon the modification.
-   [Spaghetti Code](https://sourcemaking.com/antipatterns/spaghetti-code)  
    Ad hoc software structure makes it difficult to extend and optimize code. Frequent code refactoring can improve software structure, support software maintenance, and enable iterative development.
-   [Input Kludge](https://sourcemaking.com/antipatterns/input-kludge)  
    Software that fails straightforward behavioral tests may be an example of an input kludge, which occurs when ad hoc algorithms are employed for handling program input.
-   [Walking through a Minefield](https://sourcemaking.com/antipatterns/walking-through-minefield)  
    Using today’s software technology is analogous to walking through a high-tech mine field. Numerous bugs are found in released software products; in fact, experts estimate that original source code contains two to five bugs per line of code.
-   [Cut-and-Paste Programming](https://sourcemaking.com/antipatterns/cut-and-paste-programming)  
    Code reused by copying source statements leads to significant maintenance problems. Alternative forms of reuse, including black-box reuse, reduce maintenance issues by having common source code, testing, and documentation.
-   [Mushroom Management](https://sourcemaking.com/antipatterns/mushroom-management)  
    In some architecture and management circles, there is an explicit policy to keep system developers isolated from the system’s end users. Requirements are passed second-hand through intermediaries, including architects, managers, or requirements analysts.
### [Software Architecture AntiPatterns](https://sourcemaking.com/antipatterns/software-architecture-antipatterns)
-   [Autogenerated Stovepipe](https://sourcemaking.com/antipatterns/autogenerated-stovepipe)  
    This AntiPattern occurs when migrating an existing software system to a distributed infrastructure. An Autogenerated Stovepipe arises when converting the existing software interfaces to distributed interfaces. If the same design is used for distributed computing, a number of problems emerge.
-   [Stovepipe Enterprise](https://sourcemaking.com/antipatterns/stovepipe-enterprise)  
    A Stovepipe System is characterized by a software structure that inhibits change. The refactored solution describes how to abstract subsystem and components to achieve an improved system structure. The Stovepipe Enterprise AntiPattern is characterized by a lack of coordination and planning across a set of systems.
-   [Jumble](https://sourcemaking.com/antipatterns/jumble)  
    When horizontal and vertical design elements are intermixed, an unstable architecture results. The intermingling of horizontal and vertical design elements limits the reusability and robustness of the architecture and the system software components.
-   [Stovepipe System](https://sourcemaking.com/antipatterns/stovepipe-system)  
    Subsystems are integrated in an ad hoc manner using multiple integration strategies and mechanisms, and all are integrated point to point. The integration approach for each pair of subsystems is not easily leveraged toward that of other subsystems. The Stovepipe System AntiPattern is the single-system analogy of Stovepipe Enterprise, and is concerned with how the subsystems are coordinated within a single system.
-   [Cover Your Assets](https://sourcemaking.com/antipatterns/cover-your-assets)  
    Document-driven software processes often produce less-than-useful requirements and specifications because the authors evade making important decisions. In order to avoid making a mistake, the authors take a safer course and elaborate upon alternatives.
-   [Vendor Lock-In](https://sourcemaking.com/antipatterns/vendor-lock-in)  
    Vendor Lock-In occurs in systems that are highly dependent upon proprietary architectures. The use of architectural isolation layers can provide independence from vendor-specific solutions.
-   [Wolf Ticket](https://sourcemaking.com/antipatterns/wolf-ticket)  
    A Wolf Ticket is a product that claims openness and conformance to standards that have no enforceable meaning. The products are delivered with proprietary interfaces that may vary significantly from the published standard.
-   [Architecture by Implication](https://sourcemaking.com/antipatterns/architecture-by-implication)  
    Management of risk in follow-on system development is often overlooked due to overconfidence and recent system successes. A general architecture approach that is tailored to each application system can help identify unique requirements and risk areas.
-   [Warm Bodies](https://sourcemaking.com/antipatterns/warm-bodies)  
    Software projects are often staffed with programmers with widely varying skills and productivity levels. Many of these people may be assigned to meet staff size objectives (so-called “warm bodies”). Skilled programmers are essential to the success of a software project. So-called heroic programmers are exceptionally productive, but as few as 1 in 20 have this talent. They produce an order of magnitude more working software than an average programmer.
-   [Design by Committee](https://sourcemaking.com/antipatterns/design-by-committee)  
    The classic AntiPattern from standards bodies, Design by Committee creates overly complex architectures that lack coherence. Clarification of architectural roles and improved process facilitation can refactor bad meeting processes into highly productive events.
-   [Swiss Army Knife](https://sourcemaking.com/antipatterns/swiss-army-knife)  
    A Swiss Army Knife is an excessively complex class interface. The designer attempts to provide for all possible uses of the class. In the attempt, he or she adds a large number of interface signatures in a futile attempt to meet all possible needs.
-   [Reinvent the Wheel](https://sourcemaking.com/antipatterns/reinvent-the-wheel)  
    The pervasive lack of technology transfer between software projects leads to substantial reinvention. Design knowledge buried in legacy assets can be leveraged to reduce time-to-market, cost, and risk.
-   [The Grand Old Duke of York](https://sourcemaking.com/antipatterns/the-grand-old-duke-of-york)  
    Egalitarian software processes often ignore people’s talents to the detriment of the project. Programming skill does not equate to skill in defining abstractions. There appear to be two distinct groups involved in software development: abstractionists and their counterparts the implementationists.
### [Software Project Management AntiPatterns](https://sourcemaking.com/antipatterns/software-project-management-antipatterns)






# DB design

# Terminology
The most abstract level of a database design is the _data model,_ the conceptual description of a problem space. Data models are expressed in terms of entities, attributes, domains, and relationships.
**Entities**
an _entity_ is anything about which the system needs to store information.
Designing:
- candidate entities can be most of the nouns and verbs from the domain problem space (be wary of verbs, which sound the same, but may define different entities - familiarity with problem space needed)
- review them for completeness and consistency - find duplicates and distinct entities that are masquerading as the same entity; use subtypes if entities of similar kind have different subset of attributes (if they don't - just use an attribute to mark their kind)
**Attributes**
Each column in the tuple is called an _attribute_. The number of attributes in a relation determines its _degree_. The _domain_ of an attribute is the "kind" of data it represents. A domain is _not_ the same as a data type.
**Records (Tuples)**
Each row of data is a _tuple_. Actually, each row is an n-tuple, but the "n-" is usually dropped. 
**Relationships (One-to-One, One-to-Many)**
_elationships_ are simply associations between entities.
One-to-one relationships are rare, most often being used between supertype and subtype entities.
One-to-many relationships are probably the most common type. An invoice includes many products. A salesperson creates many invoices.
many-to-many relationships are also not unusual and examples abound. Customers buy many products, and products are bought by many customers. Teachers teach many students, and students are taught by many teachers. Many-to-many relationships can't be directly implemented in the relational model, but their indirect implementation is quite straightforward
**ER notation**
E/R diagrams use rectangles to describe entities, ellipses for attributes, and diamonds to represent relationships

![enter image description here](https://static.javatpoint.com/dbms/images/dbms-notation-of-er-diagram.png)

# **normalization**
## Lossless Decomposition
The process of obtaining a fully normalized data model involves removing redundancy by dividing relations in such a way that the resultant relations can be recombined without losing any of the information. This is the principle of _lossless decomposition_.
This has customer info redundancy: (OderId, OderDate, RequiredDate, CompanyName, Address, City, PostalCode) -> (CustomerId, CompanyName, Address, City, PostalCode) + (OrderId, CustomerId, OrderDate, RequiredDate)
## Candidate Keys and Primary Keys
_candidate key_- some combination of attributes that uniquely identifies each tuple.
There might be more than one candidate key for any given relation, but it must always be the case that each candidate key uniquely identifies each tuple, not just for any specific set of tuples but for all possible tuples for all time. Candidate keys are determined by data logic, not by inspection (if you have not enough data - some combinations may seem like candidates)
By definition, all relations must have at least one candidate key: the set of all attributes comprising the tuple. Candidate keys can be composed of a single attribute (a _simple key_) or of multiple attributes (a _composite key_). However, an additional requirement of a candidate key is that it must be irreducible, so the set of all attributes is not _necessarily_ a candidate key. For example: {Id} is a candidate, {Id, Category} is not a candidate, since Category is unnecessary.
If there are many candidate keys one of them is set a primary key and the rest is alternate keys.
## Functional Dependency
Given any tuple T, with two sets of attributes {X1…Xn} and {Y1…Yn} (the sets need not be mutually exclusive), then set Y is functionally dependent on set X if, for any legal value of X, there is only one legal value for Y.
If {X} is a candidate key, then all attributes {Y} must necessarily be functional dependent on {X}; this follows from the definition of candidate key. If {X} is not a candidate key and the functional dependency is not trivial (that is, {Y} is not a subset of {X}), then the relation will necessarily involve some redundancy, and further normalization will be required.

## First Normal Form
A relation is in first normal form if the domains on which its attributes are defined are scalar. This is at once both the simplest and most difficult concept in data modeling. The principle is straightforward: each attribute of a tuple must contain a single value.
Whether the attribute is scalar with a complex data structure is defined by the semantics - if your system uses the attribute as a single value then it's scalar, otherwise it's not.

![enter image description here](http://www.gitta.info/LogicModelin/en/image/1NF.gif)

## Second Normal Form 
A relation is in second normal form if it is in first normal form and in addition all its attributes are dependent on the entire candidate key.
Here we have {IdSt, IdProf} key, but LastName of student is dependent only on IdSt and Prof on IdProf.

![enter image description here](http://www.gitta.info/LogicModelin/en/image/2NF.gif)


## Third Normal Form
A relation is in third normal form if it is in second normal form and in addition all nonkey attributes are mutually independent.
= no transitive dependencies
Here Bank is dependent on Bank_Code_No, which is dependent on the primary key.

![enter image description here](http://www.gitta.info/LogicModelin/en/image/3NF.gif)

## Boyce/Codd Normal Form
Boyce/Codd normal form, which is considered a variation of third normal form, handles the special case of relations with multiple candidate keys. In fact, for Boyce/Codd normal form to apply, the following conditions must hold true:
-   The relation must have two or more candidate keys.
-   At least two of the candidate keys must be composite.
-   The candidate keys must have overlapping attributes.

there must be no functional dependencies  _between_  candidate keys.

Book
| Title | Author | Author Nationality | Pages | Thickness | _Genre ID_ | _Publisher ID_ |
| --- | --- | --- | --- | --- | --- | --- |
| Beginning MySQL Database Design and Optimization | Chad Russell | American | 520 | Thick | _1_ | _1_ |
| The Relational Model for Database Management: Version 2 | E.F.Codd | British | 538 | Thick | _2_ | _2_ |
| Learning SQL | Alan Beaulieu | American | 338 | Slim | _1_ | _3_ |
| SQL Cookbook | Anthony Molinaro | American | 636 | Thick | _1_ | _3_ |

There is a non-trivial dependency violating [BCNF](https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form) -  **{Author} → {Author Nationality}**. Therefore, the table should be decomposed:

Book

| Title | Author | Pages | Thickness | _Genre ID_ | _Publisher ID_ |
| --- | --- | --- | --- | --- | --- |
| Beginning MySQL Database Design and Optimization | Chad Russell | 520 | Thick | _1_ | _1_ |
| The Relational Model for Database Management: Version 2 | E.F.Codd | 538 | Thick | _2_ | _2_ |
| Learning SQL | Alan Beaulieu | 338 | Slim | _1_ | _3_ |
| SQL Cookbook | Anthony Molinaro | 636 | Thick | _1_ | _3_ |

Author - Nationality

| Author | Author Nationality |
| --- | --- |
| Chad Russell | American |
| E.F.Codd | British |
| Alan Beaulieu | American |
| Anthony Molinaro | American |


## Fourth Normal Form
independent repeating groups should not be combined in a single relation

**Franchisee - Book Location**

| Franchisee ID | Title | Location |
| --- | --- | --- |
| 1 | Beginning MySQL Database Design and Optimization | California |
| 1 | Beginning MySQL Database Design and Optimization | Florida |
| 1 | Beginning MySQL Database Design and Optimization | Texas |
| 1 | The Relational Model for Database Management: Version 2 | California |
| 1 | The Relational Model for Database Management: Version 2 | Florida |
| 1 | The Relational Model for Database Management: Version 2 | Texas |
| 2 | Beginning MySQL Database Design and Optimization | California |
| 2 | Beginning MySQL Database Design and Optimization | Florida |
| 2 | Beginning MySQL Database Design and Optimization | Texas |
| 2 | The Relational Model for Database Management: Version 2 | California |
| 2 | The Relational Model for Database Management: Version 2 | Florida |
| 2 | The Relational Model for Database Management: Version 2 | Texas |
| 3 | Beginning MySQL Database Design and Optimization | Texas |

As this table structure consists of a [compound primary key](https://en.wikipedia.org/wiki/Compound_key), it doesn&#39;t contain any non-key attributes and it&#39;s already in [BCNF](https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form) (and therefore also satisfies all the previous [normal forms](https://en.wikipedia.org/wiki/Database_normalization#Normal_forms)). However, if we assume that all available books are offered in each area, we might notice that the  **Title**  is not unambiguously bound to a certain  **Location**  and therefore the table doesn&#39;t satisfy [4NF](https://en.wikipedia.org/wiki/Fourth_normal_form).

That means that, to satisfy the [fourth normal form](https://en.wikipedia.org/wiki/Fourth_normal_form), this table needs to be decomposed as well:

**Franchisee - Book**

| Franchisee ID | Title |
| --- | --- |
| 1 | Beginning MySQL Database Design and Optimization |
| 1 | The Relational Model for Database Management: Version 2 |
| 2 | Beginning MySQL Database Design and Optimization |
| 2 | The Relational Model for Database Management: Version 2 |
| 3 | Beginning MySQL Database Design and Optimization |

Franchisee - Location

| Franchisee ID | Location |
| --- | --- |
| 1 | California |
| 1 | Florida |
| 1 | Texas |
| 2 | California |
| 2 | Florida |
| 2 | Texas |
| 3 | Texas |

## Fifth Normal Form
Fifth normal form addresses the extremely rare case of _join dependencies_. A join dependency expresses the cyclical constraint "if Entity1 is linked to Entity2, and Entity2 is linked to Entity3, and Entity3 is linked back to Entity1, then all three entities must _necessarily_ coexist in the same tuple."
if {Supplier} supplies {Product}, and {Customer} ordered {Product}, and {Supplier} supplied _something_ to {Customer}, then {Supplier} supplied {Product} to {Customer}. Now, in the real world this is not a valid deduction. {Supplier} could have supplied anything to {Customer}, not necessarily {Product}. A join dependency exists only if there is an additional constraint that states that the deduction is valid.


To spot a table not satisfying the [5NF](https://en.wikipedia.org/wiki/Fifth_normal_form), it is usually necessary to examine the data thoroughly. Suppose the table from [4NF example](https://en.wikipedia.org/wiki/Database_normalization#Satisfying_4NF) with a little modification in data and let&#39;s examine if it satisfies [5NF](https://en.wikipedia.org/wiki/Fifth_normal_form):

**Franchisee - Book Location**

| Franchisee ID | Title | Location |
| --- | --- | --- |
| 1 | Beginning MySQL Database Design and Optimization | California |
| 1 | Learning SQL | California |
| 1 | The Relational Model for Database Management: Version 2 | Texas |
| 2 | The Relational Model for Database Management: Version 2 | California |

If we decompose this table, we lower redundancies and get the following two tables:

| **Franchisee - Book**

| Franchisee ID | Title |
| --- | --- |
| 1 | Beginning MySQL Database Design and Optimization |
| 1 | Learning SQL |
| 1 | The Relational Model for Database Management: Version 2 |
| 2 | The Relational Model for Database Management: Version 2 |
**Franchisee - Location**

| Franchisee ID | Location |
| --- | --- |
| 1 | California |
| 1 | Texas |
| 2 | California |

What happens if we try to join these tables? The query would return the following data:

**Franchisee - Book - Location JOINed**

| Franchisee ID | Title | Location |
| --- | --- | --- |
| 1 | Beginning MySQL Database Design and Optimization | California |
| 1 | Learning SQL | California |
| 1 | The Relational Model for Database Management: Version 2 | California |
| 1 | The Relational Model for Database Management: Version 2 | Texas |
| 1 | Learning SQL | Texas |
| 1 | Beginning MySQL Database Design and Optimization | Texas |
| 2 | The Relational Model for Database Management: Version 2 | California |

Apparently, the JOIN returns three more rows than it should - let&#39;s try to add another table to clarify the relation. We end up with three separate tables:

| **Franchisee - Book**

| Franchisee ID | Title |
| --- | --- |
| 1 | Beginning MySQL Database Design and Optimization |
| 1 | Learning SQL |
| 1 | The Relational Model for Database Management: Version 2 |
| 2 | The Relational Model for Database Management: Version 2 |

**Franchisee - Location**

| Franchisee ID | Location |
| --- | --- |
| 1 | California |
| 1 | Texas |
| 2 | California |

  | **Location - Book**

| Location | Title |
| --- | --- |
| California | Beginning MySQL Database Design and Optimization |
| California | Learning SQL |
| California | The Relational Model for Database Management: Version 2 |
| Texas | The Relational Model for Database Management: Version 2 |

What will the JOIN return now? It actually is not possible to join these three tables. That means it wasn&#39;t possible to decompose the  **Franchisee - Book Location**  without data loss, therefore the table already satisfies [5NF]

# **Data Integrity**
- rules that the database system will use to ensure that the actual physical data stored in it is, if not correct, at least plausible
- no database system, and no database system designer, can guarantee that the data in the database _is_ true, only that it _could_ be true. It does this by ensuring that the data complies with the _integrity constraints_ that have been defined for it.

## Integrity Constraints
Data integrity is implemented at several levels of granularity.

Domain, transition, and entity constraints define the rules for maintaining the integrity of the individual relations. 
- domain is the set of all possible values for a given attribute. A domain integrity constraint—usually just called a _domain constraint_—is a rule that defines these legal values. It might, of course, be necessary to define more than one domain constraint to describe a domain completely.
- Transition integrity constraints define the states through which a tuple can validly pass. You would use transitional integrity constraints, for instance, to ensure that the status of a given order never changed from "Entered" to "Completed" without passing through the interim states, or to prevent a canceled order from changing status at all. 
	- The status of an entity is usually controlled by a single attribute. In this case, transition integrity can be considered a special type of domain integrity. Sometimes, however, the valid transitions are controlled by multiple attributes or even multiple relations. Because transition constraints can exist at any level of granularity, it's useful to consider them a separate type of constraint during preparation of the data model.
- _Entity constraints_ ensure the integrity of the entities being modeled by the system. At the simplest level, the existence of a primary key is an entity constraint that enforces the rule "every entity must be uniquely identifiable."
	- In a sense, this is _the_ entity integrity constraint; all others are technically entity-level integrity constraints. The constraints defined at the entity level can govern a single attribute, multiple attributes, or the relation as a whole.
	- The integrity of an individual attribute is modeled first and foremost by defining the attribute against a specific domain. An attribute within a relation inherits the integrity constraints defined for its domain. At the entity level, these inherited constraints can properly be made more rigorous but not relaxed.
	- Entity constraints can't reference other relations


Referential integrity constraints ensure that necessary relationships between relations are maintained. 
- _Referential integrity constraints_ maintain and protect links between relations.
- There is really only one referential integrity constraint: foreign keys cannot become orphans. In other words, no record in the foreign table can contain a foreign key that doesn't match a record in the primary table. Tuples that contain foreign keys that don't have a corresponding candidate key in the primary relation are called _orphan entities_.

Database integrity constraints govern the database as a whole
- The most general form of integrity constraint is the _database constraint_. Database constraints reference more than one relation: "A Customer is not allowed to have a status of 'Preferred' unless he or she has made a purchase in the last 12 months."
- It's always a good idea to define integrity constraints as completely as possible, and database integrity is no exception. You must be careful, however, not to confuse a database constraint with the specification of a work process. A _work process_ is something that is done with the database, such as adding an order, whereas an integrity constraint is a rule about the contents of the database. The rules that define the tasks that are performed using the database are work process constraints, not database constraints.

transaction integrity constraints control the way data is manipulated either within a single database or between multiple databases.
- Transaction integrity constraints govern the ways in which the database can be manipulated. Unlike other constraints, transaction constraints are procedural and thus are not part of the data model per se.

## Implementing Data Integrity
 Unknown and Nonexistent Values
 Violation Responses - what action the database engine should take if the constraint is violated
 Declarative and Procedural Integrity:
 - _Declarative integrity_ support is explicitly defined ("declared") as part of the database schema.Declarative integrity is the preferred method for implementing data integrity. You should use it wherever possible.
 - SQL Server implements _procedural integrity_ support by way of _trigger_ procedures that are executed ("triggered") when a record is either inserted, updated, or deleted


# Modeling (UML, ER, data flow)

# UML

![enter image description here](https://www.uml-diagrams.org/uml-25-diagrams.png)

## **Official Diagram Types of the UML**

| **Diagram** | **Purpose** | **Lineage** |
| --- | --- | --- |
| Activity | Procedural and parallel behavior | In UML 1 |
| Class | Class, features, and relationships | In UML 1 |
| Communication | Interaction between objects; emphasis on links | UML 1 collaboration diagram |
| Component | Structure and connections of components | In UML 1 |
| Composite structure | Runtime decomposition of a class | New to UML 2 |
| Deployment | Deployment of artifacts to nodes | In UML 1 |
| Interaction overview | Mix of sequence and activity diagram | New to UML 2 |
| Object | Example configurations of instances | Unofficially in UML 1 |
| Package | Compile-time hierarchic structure | Unofficially in UML 1 |
| Sequence | Interaction between objects; emphasis on sequence | In UML 1 |
| State machine | How events change an object over its life | In UML 1 |
| Timing | Interaction between objects; emphasis on timing | New to UML 2 |
| Use case | How users interact with a system | In UML 1 |

## Class diagram
A class diagram describes the types of objects in the system and the various kinds of static relationships that exist among them. Class diagrams also show the properties and operations of a class and the constraints that apply to the way objects are connected. The UML uses the term feature as a general term that covers properties and operations of a class.

![enter image description here](https://i.pinimg.com/originals/e4/18/fe/e418fe80c2b2a082d8f0ab89009de71c.png)

### Properties
Properties  represent structural features of a class. As a first approximation, you can think of properties as corresponding to fields in a class. Properties are a single concept, but they appear in two quite distinct notations: attributes and associations.
#### Attributes
The  attribute  notation describes a property as a line of text within the class box itself. The full form of an attribute is:
```visibility name: type multiplicity = default {property-string}```
An example of this is:
```name: String [1] = "Untitled" {readOnly}```

Only the  name  is necessary.
-   This  visibility  marker indicates whether the attribute is public (+) or private (-); 
-   The  name  of the attribute�how the class refers to the attribute�roughly corresponds to the name of a field in a programming language.
-   The  type  of the attribute indicates a restriction on what kind of object may be placed in the attribute. You can think of this as the type of a field in a programming language.
-   The  default value  is the value for a newly created object if the attribute isn't specified during creation.
-   The  {property-string}  allows you to indicate additional properties for the attribute. In the example, I used  {readOnly}  to indicate that clients may not modify the property. If this is missing, you can usually assume that the attribute is modifiable.
#### Associations
The other way to notate a property is as an association. Much of the same information that you can show on an attribute appears on an association.

![enter image description here](https://i.ibb.co/6v7NV4M/03fig02.gif)

is the same as

![enter image description here](https://i.ibb.co/mD7ZW5L/03fig03.gif)

An  association  is a solid line between two classes, directed from the source class to the target class. The name of the property goes at the target end of the association, together with its multiplicity. The target end of the association links to the class that is the type of the property.

Although most of the same information appears in both notations, some items are different. In particular, associations can show multiplicities at both ends of the line.
### Multiplicity

The  multiplicity  of a property is an indication of how many objects may fill the property. The most common multiplicities you will see are

-   1  (An order must have exactly one customer.)
-   0..1  (A corporate customer may or may not have a single sales rep.)
-   \*  (A customer need not place an Order and there is no upper limit to the number of Orders a Customer may place�zero or more orders.)
-   Optional  implies a lower bound of 0.
    
-   Mandatory  implies a lower bound of 1 or possibly more.
    
-   Single-valued  implies an upper bound of 1.
    
-   Multivalued  implies an upper bound of more than 1: usually *.
### Bidirectional Associations

![enter image description here](https://i.ibb.co/9H6zLZL/03fig04.gif)

A bidirectional association is a pair of properties that are linked together as inverses. The Car class has property owner:Person[1], and the Person class has a property cars:Car[*].
### Operations

Operations  are the actions that a class knows to carry out. Operations most obviously correspond to the methods on a class. Normally, you don't show those operations that simply manipulate properties, because they can usually be inferred.

The full UML syntax for operations is:

```visibility name (parameter-list) : return-type {property-string}```

-   This  visibility  marker is public (+) or private (-).
    
-   The  name  is a string.
    
-   The  parameter-list  is the list of parameters for the operation.
    
-   The  return-type  is the type of the returned value, if there is one.
    
-   The  property-string  indicates property values that apply to the given operation.
    

The parameters in the parameter list are notated in a similar way to attributes. The form is:

```direction name: type = default value```

-   The  name,  type, and  default value  are the same as for attributes.
    
-   The  direction  indicates whether the parameter is input (in), output (out) or both (inout). If no direction is shown, it's assumed to be  in.
    

An example operation on account might be:
```balanceOn (date: Date) : Money```

- With conceptual models, you shouldn't use operations to specify the interface of a class. Instead, use them to indicate the principal responsibilities of that class, perhaps using a couple of words summarizing a CRC responsibility
- UML defines a query as an operation that gets a value from a class without changing the system state�in other words, without side effects.You can mark such an operation with the property string {query}. I refer to operations that do change state as modifiers, also called commands. the difference between query and modifiers is whether they change the observable state [Meyer]. The observable state is what can be perceived from the outside. An operation that updates a cache would alter the internal state but would have no effect that's observable from the outside.
- An operation is something that is invoked on an object�the procedure declaration�whereas a method is the body of a procedure. The two are different when you have polymorphism. If you have a supertype with three subtypes, each of which overrides the supertype's getPrice operation, you have one operation and four methods that implement it.
- don't use getters and setters as operations if getting and setting is all they do - for a client it's only the property they access
### Notes and Comments

Notes are comments in the diagrams. Notes can stand on their own, or they can be linked with a dashed line to the elements they are commenting


![enter image description here](https://i.ibb.co/BLCLPGy/03fig06.gif)



### Dependency

A  dependency  exists between two elements if changes to the definition of one element (the  supplier) may cause changes to the other (the  client). With classes, dependencies exist for various reasons: One class sends a message to another; one class has another as part of its data; one class mentions another as a parameter to an operation. If a class changes its interface, any message sent to that class may no longer be valid.

![enter image description here](https://i.ibb.co/L6YLdyV/03fig07.gif)

To add more detail, you can add an appropriate keyword
### Constraint Rules
The UML allows you to use anything to describe constraints. The only rule is that you put them inside braces ({}). You can use natural language, a programming language, or the UML's formal Object Constraint Language
Optionally, you can name a constraint by putting the name first, followed by a colon; for example, {disallow incest: husband and wife must not be siblings}.
### When to Use Class Diagrams
- Don't try to use all the notations available to you. Start with the simple stuff: classes, associations, attributes, generalization, and constraints.
- I've found conceptual class diagrams very useful in exploring the language of a business. For this to work, you have to work hard on keeping software out of the discussion and keeping the notation very simple.
-   Don't draw models for everything; instead, concentrate on the key areas. It is better to have a few diagrams that you use and keep up to date than to have many forgotten, obsolete models.

## Use Cases
Use cases are a technique for capturing the functional requirements of a system. Use cases work by describing the typical interactions between the users of a system and the system itself, providing a narrative of how a system is used.

A  scenario  is a sequence of steps describing an interaction between a user and a system. So if we have a Web-based on-line store, we might have a Buy a Product scenario that would say this:

> The customer browses the catalog and adds desired items to the shopping basket. When the customer wishes to pay, the customer describes the shipping and credit card information and confirms the sale. The system checks the authorization on the credit card and confirms the sale both immediately and with a follow-up e-mail.

This scenario is one thing that can happen. However, the credit card authorization might fail, and this would be a separate scenario. In another case, you may have a regular customer for whom you don't need to capture the shipping and credit card information, and this is a third scenario.

All these scenarios are different yet similar. The essence of their similarity is that in all these three scenarios, the user has the same goal: to buy a product. The user doesn't always succeed, but the goal remains. This user goal is the key to use cases: A  use case  is a set of scenarios tied together by a common user goal.

In use case�speak, the users are referred to as actors. An actor is a role that a user plays with respect to the system. Actors might include customer, customer service rep, sales manager, and product analyst. Actors carry out use cases. A single actor may perform many use cases; conversely, a use case may have several actors performing it. Usually, you have many customers, so many people can be the customer actor. Also, one person may act as more than one actor, such as a sales manager who does customer service rep tasks. An actor doesn't have to be human. If the system performs a service for another computer system, that other system is an actor.

Use cases are well known as an important part of the UML. However, the surprise is that in many ways, the definition of use cases in the UML is rather sparse. Nothing in the UML describes how you should capture the content of a use case. What the UML describes is a use case diagram, which shows how use cases relate to each other. But almost all the value of use cases lies in the content, and the diagram is of rather limited value.
### Content of a Use Case

![enter image description here](https://i.ibb.co/mFKvSNQ/09fig01.gif)

You begin by picking one of the scenarios as the main success scenario. You start the body of the use case by writing the main success scenario as a sequence of numbered steps. You then take the other scenarios and write them as extensions, describing them in terms of variations on the main success scenario. Extensions can be successes�user achieves the goal, as in 3a�or failures, as in 6a.

Each use case has a primary actor, which calls on the system to deliver a service. The primary actor is the actor with the goal the use case is trying to satisfy and is usually, but not always, the initiator of the use case. There may be other actors as well with which the system communicates while carrying out the use case. These are known as secondary actors.

Each step in a use case is an element of the interaction between an actor and the system. Each step should be a simple statement and should clearly show who is carrying out the step. The step should show the intent of the actor, not the mechanics of what the actor does. Consequently, you don't describe the user interface in the use case. Indeed, writing the use case usually precedes designing the user interface.

An extension within the use case names a condition that results in different interactions from those described in the main success scenario (MSS) and states what those differences are. Start the extension by naming the step at which the condition is detected and provide a short description of the condition. Follow the condition with numbered steps in the same style as the main success scenario. Finish these steps by describing where you return to the main success scenario, if you do.

The use case structure is a great way to brainstorm alternatives to the main success scenario. For each step, ask, How could this go differently? and in particular, What could go wrong? It's usually best to brainstorm all the extension conditions first, before you get bogged down working out the consequences. You'll probably think of more conditions this way, which translates to fewer goofs that you have to pick up later.

A complicated step in a use case can be another use case. In UML terms, we say that the first use case  includes  the second. There's no standard way to show an included use case in the text, but I find that underlining, which suggests a hyperlink, works very nicely and in many tools really will be a hyperlink.

Included use cases can be useful for a complex step that would clutter the main scenario or for steps that are repeated in several use cases. However, don't try to break down use cases into sub�use cases and subsub�use cases using functional decomposition. Such a decomposition is a good way to waste a lot of time.

As well as the steps in the scenarios, you can add some other common information to a use case.

-   A  pre-condition  describes what the system should ensure is true before the system allows the use case to begin. This is useful for telling the programmers what conditions they don't have to check for in their code.
    
-   A  guarantee  describes what the system will ensure at the end of the use case. Success guarantees hold after a successful scenario; minimal guarantees hold after any scenario.
    
-   A  trigger  specifies the event that gets the use case started.
    

When you're considering adding elements, be skeptical. It's better to do too little than too much. Also, work hard to keep the use case brief and easy to read. I've found that long, detailed use cases don't get read, which rather defeats the purpose.

### Use Case Diagrams

![enter image description here](https://i.ibb.co/zm929Jg/09fig02.gif)

In your use case work, don't put too much effort into the diagram. Instead, concentrate on the textual content of the use cases.
The best way to think of a use case diagram is that it's a graphical table of contents for the use case set. It's also similar to the context diagram used in structured methods, as it shows the system boundary and the interactions with the outside world. The use case diagram shows the actors, the use cases, and the relationships between them:

-   Which actors carry out which use cases
    
-   Which use cases include other use cases
    

The UML includes other relationships between use cases beyond the simple includes, such as  «extend». I strongly suggest that you ignore them. I've seen too many situations in which teams can get terribly hung up on when to use different use case relationships, and such energy is wasted. Instead, concentrate on the textual description of a use case; that's where the real value of the technique lies.

### Levels of Use Cases
A common problem with use cases is that by focusing on the interaction between a user and the system, you can neglect situations in which a change to a business process may be the best way to deal with the problem. Often, you hear people talk about **system use cases** and **business use cases**. The terms are not precise, but in general, a **system** use case is an interaction with the software, whereas a **business** use case discusses how a business responds to a customer or an event.
The core use cases are at "sea level." Sea-level use cases typically represent a discrete interaction between a primary actor and the system. Such use cases will deliver something of value to the primary actor and usually take from a couple of minutes to half an hour for the primary actor to complete. Use cases that are there only because they are included by sea-level use cases are fish level. Higher, kite-level use cases show how the sea-level use cases fit into wider business interactions. Kite-level use cases are usually business use cases, whereas sea and fish levels are system use cases. You should have most of your use cases at the sea level.

### Use Cases and Features (or Stories)
Many approaches use features of a system�Extreme Programming calls them user stories�to help describe requirements. A common question is how features and use cases interrelate.

Features are a good way of chunking up a system for planning an iterative project, whereby each iteration delivers a number of features. Use cases provide a narrative of how the actors use the system. Hence, although both techniques describe requirements, their purposes are different.

Although you can go directly to describing features, many people find it helpful to develop use cases first and then generate a list of features. A feature may be a whole use case, a scenario in a use case, a step in a use case, or some variant behavior, such as adding yet another depreciation method for your asset valuations, that doesn't show up in a use case narrative. Usually, features end up being more fine grained than use cases.

### When to Use Use Cases
Use cases are a valuable tool to help understand the functional requirements of a system. A first pass at use cases should be made early on. More detailed versions of use cases should be worked just prior to developing that use case.

It is important to remember that use cases represent an  external  view of the system. As such, don't expect any correlations between use cases and the classes inside the system.

The more I see of use cases, the less valuable the use case diagram seems to be. With use cases, concentrate your energy on their text rather than on the diagram. Despite the fact that the UML has nothing to say about the use case text, it is the text that contains all the value in the technique.

A big danger of use cases is that people make them too complicated and get stuck. Usually, you'll get less hurt by doing too little than by doing too much. A couple of pages per use case is just fine for most cases. If you have too little, at least you'll have a short, readable document that's a starting point for questions. If you have too much, hardly anyone will read and understand it.

# ER
![enter image description here](https://wcs.smartdraw.com/entity-relationship-diagram/img/erd.jpg?bn=1510011154)

An entity relationship diagram (ERD) shows the relationships of entity sets stored in a database. An entity in this context is an object, a component of data. An entity set is a collection of similar entities. These entities can have attributes that define its properties.
By defining the entities, their attributes, and showing the relationships between them, an ER diagram illustrates the logical structure of databases.

ER diagrams are used to sketch out the design of a database.
## Common Entity Relationship Diagram Symbols

An ER diagram is a means of visualizing how the information a system produces is related. There are five main components of an ERD:

-   **Entities**, which are represented by rectangles. An entity is an object or concept about which you want to store information.  ![Entity - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/entity.jpg?bn=1510011154)  A weak entity is an entity that must defined by a foreign key relationship with another entity as it cannot be uniquely identified by its own attributes alone.  ![Weak entity - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/weak-entity.jpg?bn=1510011154)
-   **Actions**, which are represented by diamond shapes, show how two entities share information in the database.  ![Action - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/action.jpg?bn=1510011154)  In some cases, entities can be self-linked. For example, employees can supervise other employees.  
    ![Self-linked Action - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/action-selflinked.jpg?bn=1510011154)
-   **Attributes**, which are represented by ovals. A key attribute is the unique, distinguishing characteristic of the entity. For example, an employee's social security number might be the employee's key attribute.  
    ![Attribute - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/attribute.jpg?bn=1510011154)  A multivalued attribute can have more than one value. For example, an employee entity can have multiple skill values.  ![Multi-valued Attribute - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/multivalued-attribute.jpg?bn=1510011154)  A derived attribute is based on another attribute. For example, an employee's monthly salary is based on the employee's annual salary.  ![Derived Attribute - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/derived-attribute.jpg?bn=1510011154)
-   **Connecting lines**, solid lines that connect attributes to show the relationships of entities in the diagram.
-   **Cardinality**  specifies how many instances of an entity relate to one instance of another entity. Ordinality is also closely linked to cardinality. While cardinality specifies the occurrences of a relationship, ordinality describes the relationship as either mandatory or optional. In other words, cardinality specifies the maximum number of relationships and ordinality specifies the absolute minimum number of relationships.  
    ![Cardinality - ERD Symbol](https://wcs.smartdraw.com/entity-relationship-diagram/img/cardinality.jpg?bn=1510011154)  There are many notation styles that express cardinality.  
    **Information Engineering Style**  
    ![Information Engineering Style Cardinality - ERD](https://wcs.smartdraw.com/entity-relationship-diagram/img/information-engineering-style.jpg?bn=1510011154)  **Chen Style**  
    ![Chen Style Cardinality - ERD](https://wcs.smartdraw.com/entity-relationship-diagram/img/chen-style.jpg?bn=1510011154)  **Bachman Style**  
    ![Bachman Style Cardinality - ERD](https://wcs.smartdraw.com/entity-relationship-diagram/img/bachman-style.jpg?bn=1510011154)  **Martin Style**  
    ![Martin Style Cardinality - ERD](https://wcs.smartdraw.com/entity-relationship-diagram/img/martin-style.jpg?bn=1510011154)
    ## Tips for Effective ER Diagrams

1.  Make sure that each entity only appears once per diagram.
2.  Name every entity, relationship, and attribute on your diagram.
3.  Examine relationships between entities closely. Are they necessary? Are there any relationships missing? Eliminate any redundant relationships. Don't connect relationships to each other.
4.  Use colors to highlight important portions of your diagram
# Data flow diagrams
![enter image description here](https://wcs.smartdraw.com/data-flow-diagram/img/data-flow-diagram.jpg?bn=1510011154)
A data flow diagram (DFD) illustrates how data is processed by a system in terms of inputs and outputs. As its name indicates its focus is on the flow of information, where data comes from, where it goes and how it gets stored.

**Making a data flow diagram involves a few simple steps:**

1.  Add symbols that represent processes, datastores, dataflows and external entities
2.  Connect symbols with lines to represent the flow of information
3.  Add text
4.  Show any loops back to previous steps or link to subprocesses
## Data Flow Diagrams Symbols

There are essentially two different types of notations for data flow diagrams (Yourdon & Coad or Gane & Sarson) defining different visual representations for processes, data stores, data flow and external entities.

Yourdon and Coad type data flow diagrams are usually used for system analysis and design, while Gane and Sarson type DFDs are more common for visualizing information systems.

Visually, the biggest difference between the two ways of drawing data flow diagrams is how processes look. In the Yourdon and Coad way, processes are depicted as circles, while in the Gane and Sarson diagram the processes are squares with rounded corners.

**Process Notations.**  A process transforms incoming data flow into outgoing data flow.

![DFD Process Notation](https://wcs.smartdraw.com/data-flow-diagram/img/process-gane.jpg?bn=1510011154)

**Datastore Notations.**  Datastores are repositories of data in the system. They are sometimes also referred to as files.

![DFD Datastore Notation](https://wcs.smartdraw.com/data-flow-diagram/img/datastore-symbol.jpg?bn=1510011154)

**Dataflow Notations.**  Dataflows are pipelines through which packets of information flow. Label the arrows with the name of the data that moves through it.

![DFD Dataflow Notation](https://wcs.smartdraw.com/data-flow-diagram/img/dataflow-symbol.jpg?bn=1510011154)

**External Entity Notations.**  External entities are objects outside the system, with which the system communicates. External entities are sources and destinations of the system's inputs and outputs.

![DFD External Entity Notation](https://wcs.smartdraw.com/data-flow-diagram/img/external-entity.jpg?bn=1510011154)

## Data Flow Diagram Levels

Context Diagram. A context diagram is a top level (also known as "Level 0") data flow diagram. It only contains one process node ("Process 0") that generalizes the function of the entire system in relationship to external entities.

**DFD Layers.**  Draw data flow diagrams can be made in several nested layers. A single process node on a high level diagram can be expanded to show a more detailed data flow diagram. Draw the context diagram first, followed by various layers of data flow diagrams.

**DFD Levels.**  The first level DFD shows the main processes within the system. Each of these processes can be broken into further processes until you reach pseudo code.


